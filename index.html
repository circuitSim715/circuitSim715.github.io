<!DOCTYPE html>

<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulic Pro â€” I2C OLED Update</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Syne:wght@400;600;700;800&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep:    #0f1520;
            --bg-base:    #141c2e;
            --bg-surface: rgba(255,255,255,0.03);
            --bg-raised:  rgba(255,255,255,0.05);
            --bg-hover:   rgba(255,255,255,0.07);
            --bg-active:  rgba(0,212,255,0.08);

```
        --glass-border:       rgba(255,255,255,0.07);
        --glass-border-light: rgba(255,255,255,0.12);
        --glass-border-cyan:  rgba(0,212,255,0.25);

        --cyan:      #00d4ff;
        --cyan-dim:  #0088aa;
        --cyan-mute: rgba(0,212,255,0.15);
        --green:     #00e676;
        --green-dim: rgba(0,230,118,0.12);
        --amber:     #ffb700;
        --red:       #ff4757;
        --red-dim:   rgba(255,71,87,0.12);
        --purple:    #a78bfa;

        --text-bright: #e8ecf4;
        --text-mid:    #8892a4;
        --text-dim:    #3d4559;
        --text-cyan:   #00d4ff;

        --radius-sm: 4px;
        --radius-md: 6px;
        --radius-lg: 10px;
    }

    /* FIX FLASH: -webkit-tap-highlight-color elimina el highlight negro nativo
       del sistema operativo que aparece en touchstart en iOS/Android.
       Sin esto, el navegador pinta su propio overlay oscuro por 1 frame. */
    * {
        user-select: none;
        box-sizing: border-box;
        touch-action: none;
        margin: 0;
        padding: 0;
        -webkit-tap-highlight-color: transparent;
        -webkit-touch-callout: none;
    }

    body {
        background:
            radial-gradient(ellipse 60% 40% at 15% 0%, rgba(0,212,255,0.04) 0%, transparent 70%),
            radial-gradient(ellipse 40% 30% at 85% 100%, rgba(0,230,118,0.03) 0%, transparent 70%),
            var(--bg-deep);
        color: var(--text-bright);
        font-family: 'Inter', sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       HEADER BAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #header {
        position: relative;
        z-index: 10;
        display: flex;
        align-items: center;
        padding: 0 18px;
        height: 46px;
        background: rgba(11,14,23,0.9);
        border-bottom: 1px solid var(--glass-border);
        backdrop-filter: blur(20px);
        flex-shrink: 0;
        gap: 16px;
    }

    .logo-wrap {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .logo-icon {
        width: 28px; height: 28px;
        background: linear-gradient(135deg, var(--cyan) 0%, #0088aa 100%);
        border-radius: var(--radius-sm);
        display: flex; align-items: center; justify-content: center;
        font-size: 13px; font-weight: 800;
        color: #07090f;
        font-family: 'Syne', sans-serif;
        letter-spacing: -1px;
        flex-shrink: 0;
    }

    .logo-text {
        font-family: 'Syne', sans-serif;
        font-weight: 800;
        font-size: 14px;
        letter-spacing: 2px;
        color: var(--text-bright);
    }

    .logo-version {
        font-family: 'DM Mono', monospace;
        font-size: 9px;
        color: var(--text-dim);
        letter-spacing: 1px;
        padding: 2px 6px;
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-sm);
        background: var(--bg-surface);
        font-weight: 300;
    }

    .header-divider {
        width: 1px; height: 20px;
        background: var(--glass-border);
    }

    .status-pill {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 3px 10px;
        border: 1px solid var(--glass-border);
        border-radius: 20px;
        background: var(--bg-surface);
    }

    .status-dot {
        width: 5px; height: 5px;
        border-radius: 50%;
        background: var(--green);
        box-shadow: 0 0 6px var(--green);
        animation: blink 3s ease-in-out infinite;
    }

    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
    }

    .status-label {
        font-family: 'DM Mono', monospace;
        font-size: 9px;
        color: var(--text-mid);
        letter-spacing: 1px;
        font-weight: 300;
    }

    .header-right {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .hdr-btn {
        height: 28px;
        padding: 0 12px;
        background: var(--bg-surface);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-sm);
        color: var(--text-mid);
        cursor: pointer;
        font-family: 'DM Mono', monospace;
        font-size: 10px;
        font-weight: 400;
        letter-spacing: 0.5px;
        transition: all 0.15s;
        white-space: nowrap;
    }

    .hdr-btn:hover { background: var(--bg-hover); border-color: var(--glass-border-light); color: var(--text-bright); }

    .hdr-btn-mode { color: var(--cyan-dim); border-color: rgba(0,136,170,0.3); }
    .hdr-btn-mode:hover { color: var(--cyan); border-color: var(--glass-border-cyan); background: var(--bg-active); }

    .hdr-btn-danger { color: var(--red); border-color: rgba(255,71,87,0.2); background: var(--red-dim); }
    .hdr-btn-danger:hover { background: rgba(255,71,87,0.18); border-color: rgba(255,71,87,0.4); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CATEGORY TOOLBAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #ui-top {
        position: relative;
        z-index: 9;
        display: flex;
        align-items: stretch;
        height: 38px;
        background: rgba(11,14,23,0.7);
        border-bottom: 1px solid var(--glass-border);
        backdrop-filter: blur(12px);
        overflow-x: auto;
        flex-shrink: 0;
    }

    #ui-top::-webkit-scrollbar { height: 0; }

    .cat-group {
        display: flex;
        align-items: stretch;
        padding: 0 6px;
        gap: 2px;
        border-right: 1px solid var(--glass-border);
    }

    .cat-group:last-child { border-right: none; margin-left: auto; }

    .cat-btn {
        padding: 0 14px;
        background: transparent;
        border: none;
        color: var(--text-dim);
        cursor: pointer;
        font-family: 'Inter', sans-serif;
        font-size: 11px;
        font-weight: 500;
        letter-spacing: 0.3px;
        white-space: nowrap;
        border-radius: var(--radius-sm);
        position: relative;
        transition: color 0.15s, background 0.15s;
    }

    .cat-btn:hover { color: var(--text-mid); background: var(--bg-surface); }

    .cat-btn.active {
        color: var(--cyan);
        background: var(--bg-active);
    }

    .cat-btn.active::after {
        content: '';
        position: absolute;
        bottom: 0; left: 12px; right: 12px;
        height: 1.5px;
        background: var(--cyan);
        border-radius: 1px;
    }

    .cat-btn-demo { color: rgba(167,139,250,0.5); }
    .cat-btn-demo:hover { color: var(--purple); }
    .cat-btn-demo.active { color: var(--purple); background: rgba(167,139,250,0.08); }
    .cat-btn-demo.active::after { background: var(--purple); }

    .cat-btn-manual { color: rgba(255,183,0,0.5); }
    .cat-btn-manual:hover { color: var(--amber); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SPAWN / COMPONENT BAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #ui-sub {
        position: relative;
        z-index: 8;
        display: flex;
        align-items: center;
        gap: 5px;
        padding: 0 14px;
        height: 38px;
        background: rgba(7,9,15,0.6);
        border-bottom: 1px solid var(--glass-border);
        backdrop-filter: blur(8px);
        overflow-x: auto;
        flex-shrink: 0;
    }

    #ui-sub::-webkit-scrollbar { height: 0; }

    .sub-hint {
        font-family: 'DM Mono', monospace;
        font-size: 9px;
        color: var(--text-dim);
        letter-spacing: 1px;
        font-weight: 300;
    }

    .spawn-btn {
        height: 24px;
        padding: 0 12px;
        background: var(--bg-surface);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-sm);
        color: var(--text-mid);
        cursor: pointer;
        font-family: 'Inter', sans-serif;
        font-size: 10px;
        font-weight: 500;
        white-space: nowrap;
        flex-shrink: 0;
        transition: all 0.12s;
    }

    .spawn-btn:hover {
        background: var(--bg-hover);
        border-color: var(--glass-border-light);
        color: var(--text-bright);
    }

    .spawn-btn:active {
        background: var(--bg-active);
        border-color: var(--glass-border-cyan);
        color: var(--cyan);
        transform: scale(0.97);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CANVAS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #canvas-container {
        flex: 1;
        position: relative;
        overflow: hidden;
        background: var(--bg-deep);
        cursor: crosshair;
        z-index: 1;
    }

    canvas {
        width: 100%;
        height: 100%;
        display: block;
        background: var(--bg-deep);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       ZOOM + HUD
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #zoom-controls {
        position: absolute;
        right: 14px;
        top: 14px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        z-index: 20;
        background: rgba(11,14,23,0.75);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        backdrop-filter: blur(20px);
        padding: 4px;
    }

    .zoom-btn {
        width: 30px; height: 30px;
        display: flex; align-items: center; justify-content: center;
        background: transparent;
        border: none;
        border-radius: var(--radius-sm);
        color: var(--text-mid);
        cursor: pointer;
        font-family: 'DM Mono', monospace;
        font-size: 14px;
        transition: all 0.12s;
    }

    .zoom-btn:hover { background: var(--bg-hover); color: var(--cyan); }
    .zoom-btn:active { transform: scale(0.9); }

    .zoom-divider { height: 1px; background: var(--glass-border); margin: 0 4px; }

    #hud-coords {
        position: absolute;
        left: 14px;
        top: 14px;
        font-family: 'DM Mono', monospace;
        font-size: 9px;
        color: var(--text-dim);
        letter-spacing: 0.5px;
        background: rgba(11,14,23,0.75);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-md);
        padding: 7px 12px;
        line-height: 1.8;
        backdrop-filter: blur(20px);
        pointer-events: none;
        z-index: 20;
    }

    #hud-coords span { color: var(--text-mid); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       VIRTUAL CONTROLS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #virtual-controls { display: none !important; }

    /* MenÃº contextual flotante para touch nativo */
    #touch-ctx-menu {
        display: none;
        position: fixed;
        z-index: 200;
        background: rgba(11,14,23,0.96);
        backdrop-filter: blur(24px);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 14px;
        padding: 6px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.6);
        flex-direction: column;
        gap: 2px;
        min-width: 160px;
        animation: tcm-in 0.15s ease;
    }
    #touch-ctx-menu.visible { display: flex; }

    @keyframes tcm-in {
        from { opacity:0; transform: scale(0.88) translateY(6px); }
        to   { opacity:1; transform: scale(1)    translateY(0); }
    }

    .tcm-item {
        display: flex; align-items: center; gap: 10px;
        padding: 11px 14px;
        border-radius: 9px;
        font-family: 'DM Mono', monospace;
        font-size: 12px;
        color: rgba(255,255,255,0.75);
        cursor: pointer;
        transition: background 0.1s;
        user-select: none;
    }
    .tcm-item:active { background: rgba(255,255,255,0.08); }
    .tcm-item .tcm-icon { font-size: 15px; width: 20px; text-align: center; }
    .tcm-item.tcm-danger { color: rgba(255,71,87,0.85); }
    .tcm-item.tcm-danger:active { background: rgba(255,71,87,0.1); }
    .tcm-sep { height: 1px; background: rgba(255,255,255,0.06); margin: 3px 0; }

    #fx-overlay {
        position: fixed;
        inset: 0;
        pointer-events: none;
        z-index: 100;
        background: transparent;
    }

    /* FIX CÃRCULO NEGRO: el ripple empezaba en width:0/height:0, lo que
       hacÃ­a que el navegador mobile pintara un cÃ­rculo negro sÃ³lido durante
       el primer frame de la animaciÃ³n (antes de que border-radius surtiera
       efecto visible). SoluciÃ³n: empezar desde un tamaÃ±o ya visible (20px)
       y con opacity baja, asÃ­ el elemento nunca es un punto negro opaco. */
    .touch-ripple {
        position: fixed;
        pointer-events: none;
        border-radius: 50%;
        border: 1.5px solid rgba(0,212,255,0.5);
        /* Sin background: transparent explÃ­cito, el navegador asignaba
           el color de sistema (#000) en el primer frame */
        background: transparent;
        animation: ripple-anim 0.4s ease-out forwards;
        z-index: 100;
        will-change: transform, opacity;
        transform: translate(-50%, -50%);
    }
    @keyframes ripple-anim {
        /* Arrancamos desde 20px ya visible, no desde 0 */
        from { width:20px; height:20px; opacity:0.5; transform:translate(-50%,-50%); }
        to   { width:60px; height:60px; opacity:0;   transform:translate(-50%,-50%); }
    }

    .hold-ring {
        position: fixed;
        pointer-events: none;
        border-radius: 50%;
        border: 2px solid rgba(0,230,118,0.6);
        width: 48px; height: 48px;
        z-index: 100;
        will-change: transform, opacity;
        animation: hold-ring-anim 0.45s ease-out forwards;
    }
    @keyframes hold-ring-anim {
        from { transform: translate(-50%,-50%) scale(0.3); opacity:0.9; }
        to   { transform: translate(-50%,-50%) scale(1);   opacity:0; }
    }

    .hold-progress {
        position: fixed;
        pointer-events: none;
        width: 52px; height: 52px;
        z-index: 101;
        will-change: transform;
        background: transparent;
        overflow: visible;
    }
    .hold-progress circle {
        fill: none;
        stroke: rgba(0,212,255,0.8);
        stroke-width: 2.5;
        stroke-linecap: round;
        stroke-dasharray: 138;
        stroke-dashoffset: 138;
        transform-origin: 26px 26px;
        transform: rotate(-90deg);
        animation: hold-progress-anim 0.44s linear forwards;
    }
    @keyframes hold-progress-anim {
        from { stroke-dashoffset: 138; }
        to   { stroke-dashoffset: 0; }
    }

    #cable-badge {
        display: none;
        position: fixed;
        top: 60px; left: 50%;
        transform: translateX(-50%);
        background: rgba(0,212,255,0.15);
        border: 1px solid rgba(0,212,255,0.4);
        border-radius: 20px;
        padding: 6px 16px;
        font-family: 'DM Mono', monospace;
        font-size: 11px;
        color: rgba(0,212,255,0.9);
        z-index: 150;
        pointer-events: auto;
        backdrop-filter: blur(8px);
        animation: badge-in 0.2s ease;
        display: none;
        align-items: center;
        gap: 10px;
    }
    #cable-badge.visible { display: flex; }
    #cable-badge-cancel {
        background: rgba(255,80,80,0.2);
        border: 1px solid rgba(255,80,80,0.5);
        border-radius: 10px;
        color: rgba(255,100,100,0.95);
        font-size: 10px;
        padding: 2px 8px;
        cursor: pointer;
        font-family: 'DM Mono', monospace;
    }
    @keyframes badge-in {
        from { opacity:0; transform: translateX(-50%) translateY(-8px); }
        to   { opacity:1; transform: translateX(-50%) translateY(0); }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MODAL
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #modal {
        display: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(11,14,23,0.92);
        border: 1px solid var(--glass-border-light);
        border-radius: var(--radius-lg);
        backdrop-filter: blur(40px);
        box-shadow: 0 24px 80px rgba(0,0,0,0.7), 0 0 0 1px var(--glass-border);
        z-index: 100;
        width: 320px;
        overflow: hidden;
        transition: width 0.2s ease;
    }

    #modal.code-mode {
        width: 520px;
    }

    .code-editor-wrap {
        display: none;
        flex-direction: column;
        margin-bottom: 12px;
        border: 1px solid var(--glass-border-light);
        border-radius: var(--radius-sm);
        overflow: hidden;
        background: rgba(0,0,0,0.55);
    }

    .code-toolbar {
        display: flex;
        align-items: center;
        gap: 4px;
        padding: 5px 8px;
        background: rgba(255,255,255,0.03);
        border-bottom: 1px solid var(--glass-border);
    }

    .code-toolbar-label {
        font-family: 'DM Mono', monospace;
        font-size: 9px;
        color: var(--text-dim);
        letter-spacing: 1px;
        margin-right: auto;
    }

    .code-snippet-btn {
        padding: 2px 7px;
        background: rgba(255,255,255,0.04);
        border: 1px solid var(--glass-border);
        border-radius: 3px;
        color: var(--text-dim);
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        cursor: pointer;
        transition: all 0.1s;
        white-space: nowrap;
    }
    .code-snippet-btn:hover { background: var(--bg-active); border-color: var(--glass-border-cyan); color: var(--cyan); }

    .code-body {
        display: flex;
        height: 180px;
        overflow: hidden;
    }

    .code-lines {
        width: 32px;
        flex-shrink: 0;
        background: rgba(0,0,0,0.3);
        border-right: 1px solid var(--glass-border);
        padding: 10px 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        padding-right: 6px;
    }

    .line-num {
        font-family: 'DM Mono', monospace;
        font-size: 10px;
        color: var(--text-dim);
        line-height: 1.7em;
        min-height: 1.7em;
        font-weight: 300;
        opacity: 0.5;
    }

    #m-code-area {
        flex: 1;
        height: 100%;
        background: transparent;
        color: #a8d8c8;
        border: none;
        font-family: 'DM Mono', monospace;
        font-size: 11px;
        font-weight: 300;
        line-height: 1.7;
        padding: 10px 10px;
        resize: none;
        display: block;
        outline: none;
        tab-size: 2;
        caret-color: var(--cyan);
        scrollbar-width: thin;
        scrollbar-color: rgba(255,255,255,0.08) transparent;
    }

    #m-code-area::placeholder { color: var(--text-dim); }

    .code-statusbar {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 4px 10px;
        background: rgba(0,0,0,0.3);
        border-top: 1px solid var(--glass-border);
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        color: var(--text-dim);
    }

    .code-status-item { display: flex; align-items: center; gap: 4px; }
    .code-status-dot { width: 5px; height: 5px; border-radius: 50%; background: var(--green); }

    #log-console {
        background: rgba(0,0,0,0.6);
        border-top: 1px solid var(--glass-border);
        height: 100px;
        overflow-y: auto;
        font-family: 'DM Mono', monospace;
        font-size: 10px;
        font-weight: 300;
        line-height: 1.7;
        scrollbar-width: thin;
        scrollbar-color: rgba(255,255,255,0.06) transparent;
    }

    .console-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 3px 10px;
        background: rgba(0,0,0,0.4);
        border-top: 1px solid var(--glass-border);
        border-bottom: 1px solid var(--glass-border);
        position: sticky;
        top: 0;
        z-index: 1;
    }

    .console-header-label {
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        color: var(--text-dim);
        letter-spacing: 1.5px;
    }

    .console-clear-btn {
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        color: rgba(255,71,87,0.5);
        background: none;
        border: 1px solid rgba(255,71,87,0.2);
        border-radius: 3px;
        padding: 1px 6px;
        cursor: pointer;
        transition: all 0.1s;
    }

    .console-clear-btn:hover { color: var(--red); border-color: rgba(255,71,87,0.5); background: rgba(255,71,87,0.06); }

    .console-line {
        padding: 0 10px;
        white-space: pre-wrap;
        word-break: break-all;
    }

    .console-line.log-init   { color: rgba(0,212,255,0.5); }
    .console-line.log-info   { color: rgba(0,230,118,0.8); }
    .console-line.log-warn   { color: rgba(255,183,0,0.85); }
    .console-line.log-error  { color: rgba(255,71,87,0.9); }
    .console-line.log-print  { color: #c8e6c9; }
    .console-line.log-dim    { color: var(--text-dim); }

    .modal-titlebar {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        border-bottom: 1px solid var(--glass-border);
        gap: 10px;
    }

    .modal-accent {
        width: 2px; height: 14px;
        background: var(--cyan);
        border-radius: 2px;
    }

    #m-title {
        font-family: 'Syne', sans-serif;
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 1.5px;
        color: var(--text-bright);
    }

    .modal-body { padding: 16px; }

    .modal-field {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 12px;
        background: rgba(255,255,255,0.03);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-sm);
        margin-bottom: 12px;
    }

    #m-val {
        flex: 1;
        background: transparent;
        border: none;
        color: var(--cyan);
        font-family: 'DM Mono', monospace;
        font-size: 18px;
        font-weight: 300;
        text-align: center;
        outline: none;
        width: 80px;
    }

    #m-unit {
        font-family: 'DM Mono', monospace;
        font-size: 11px;
        color: var(--text-dim);
    }

    .modal-actions {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
    }

    .modal-btn {
        height: 28px;
        padding: 0 14px;
        background: var(--bg-surface);
        border: 1px solid var(--glass-border);
        border-radius: var(--radius-sm);
        color: var(--text-mid);
        cursor: pointer;
        font-family: 'Inter', sans-serif;
        font-size: 10px;
        font-weight: 500;
        letter-spacing: 0.3px;
        transition: all 0.12s;
    }

    .modal-btn:hover { background: var(--bg-hover); color: var(--text-bright); border-color: var(--glass-border-light); }

    .modal-btn-save { color: var(--cyan); border-color: rgba(0,212,255,0.25); background: var(--bg-active); }
    .modal-btn-save:hover { background: rgba(0,212,255,0.15); border-color: var(--glass-border-cyan); }

    .modal-btn-rep { color: var(--amber); border-color: rgba(255,183,0,0.25); }
    .modal-btn-rep:hover { background: rgba(255,183,0,0.1); border-color: rgba(255,183,0,0.4); }

    .modal-btn-toggle { color: var(--cyan-dim); border-color: rgba(0,136,170,0.3); }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MANUAL
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #manual-screen {
        display: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 86%; height: 88%;
        background: rgba(11,14,23,0.96);
        border: 1px solid var(--glass-border-light);
        border-radius: var(--radius-lg);
        backdrop-filter: blur(40px);
        box-shadow: 0 32px 100px rgba(0,0,0,0.8);
        z-index: 300;
        overflow: hidden;
    }

    .manual-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 20px;
        border-bottom: 1px solid var(--glass-border);
    }

    .manual-title-wrap { display: flex; align-items: center; gap: 10px; }

    .manual-title {
        font-family: 'Syne', sans-serif;
        font-size: 13px;
        font-weight: 700;
        letter-spacing: 2px;
        color: var(--text-bright);
    }

    .manual-badge {
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        color: var(--amber);
        border: 1px solid rgba(255,183,0,0.3);
        border-radius: 3px;
        padding: 1px 6px;
        letter-spacing: 1px;
    }

    .close-manual {
        height: 26px;
        padding: 0 12px;
        background: var(--red-dim);
        border: 1px solid rgba(255,71,87,0.25);
        border-radius: var(--radius-sm);
        color: var(--red);
        cursor: pointer;
        font-family: 'Inter', sans-serif;
        font-size: 10px;
        font-weight: 500;
        transition: all 0.12s;
    }

    .close-manual:hover { background: rgba(255,71,87,0.2); border-color: rgba(255,71,87,0.45); }

    .manual-inner {
        height: calc(100% - 56px);
        overflow-y: auto;
        padding: 24px 28px;
    }

    .manual-inner::-webkit-scrollbar { width: 3px; }
    .manual-inner::-webkit-scrollbar-track { background: transparent; }
    .manual-inner::-webkit-scrollbar-thumb { background: var(--glass-border-light); border-radius: 2px; }

    #manual-screen h4 {
        font-family: 'Syne', sans-serif;
        font-size: 10px;
        font-weight: 700;
        letter-spacing: 2px;
        color: var(--cyan);
        margin: 22px 0 10px;
        text-transform: uppercase;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    #manual-screen h4::before {
        content: '';
        width: 16px; height: 1px;
        background: var(--cyan);
        opacity: 0.5;
    }

    #manual-screen p, #manual-screen li {
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        line-height: 1.9;
        color: var(--text-mid);
        font-weight: 300;
    }

    #manual-screen strong { color: var(--text-bright); font-weight: 500; }
    #manual-screen ul { padding-left: 16px; }

    #manual-screen pre {
        background: rgba(0,0,0,0.5);
        border: 1px solid var(--glass-border);
        border-left: 2px solid rgba(255,183,0,0.4);
        border-radius: var(--radius-sm);
        padding: 12px 14px;
        color: #a3c4a3;
        font-family: 'DM Mono', monospace;
        font-size: 11px;
        font-weight: 300;
        overflow-x: auto;
        margin: 10px 0;
    }

    #manual-screen code {
        background: rgba(0,212,255,0.07);
        border: 1px solid rgba(0,212,255,0.15);
        border-radius: 3px;
        padding: 1px 5px;
        color: var(--cyan);
        font-family: 'DM Mono', monospace;
        font-size: 10.5px;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       CONTEXT MENU
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    #context-menu {
        display: none;
        position: absolute;
        background: rgba(11,14,23,0.95);
        border: 1px solid var(--glass-border-light);
        border-radius: var(--radius-md);
        backdrop-filter: blur(30px);
        box-shadow: 0 12px 40px rgba(0,0,0,0.7);
        z-index: 200;
        min-width: 150px;
        overflow: hidden;
    }

    .ctx-section {
        padding: 6px 8px 2px;
        font-family: 'DM Mono', monospace;
        font-size: 8px;
        color: var(--text-dim);
        letter-spacing: 1.5px;
    }

    .ctx-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 7px 12px;
        color: var(--text-mid);
        cursor: pointer;
        font-family: 'Inter', sans-serif;
        font-size: 12px;
        font-weight: 400;
        transition: all 0.1s;
    }

    .ctx-item:hover { background: var(--bg-hover); color: var(--text-bright); }

    .ctx-icon {
        width: 14px; text-align: center;
        font-size: 11px;
        color: var(--text-dim);
    }

    .ctx-item:hover .ctx-icon { color: var(--cyan); }

    .ctx-item.danger:hover { background: var(--red-dim); color: var(--red); }
    .ctx-item.danger:hover .ctx-icon { color: var(--red); }

    .ctx-separator { height: 1px; background: var(--glass-border); margin: 3px 0; }

    .desktop-mode #virtual-controls { display: none !important; }
    .desktop-mode #zoom-controls { top: auto; bottom: 16px; right: 16px; }

    #about-screen {
        display: none;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        width: 60%; max-width: 540px;
        height: auto; max-height: 80%;
        background: rgba(11,14,23,0.96);
        border: 1px solid var(--glass-border-light);
        border-radius: var(--radius-lg);
        backdrop-filter: blur(40px);
        box-shadow: 0 32px 100px rgba(0,0,0,0.8);
        z-index: 300;
        overflow: hidden;
    }
</style>
```

</head>
<body>

<!-- HEADER -->

<div id="header">
    <div class="logo-wrap">
        <div class="logo-icon">SP</div>
        <span class="logo-text">SIMULIC</span>
        <span class="logo-version">v1.8 Â· I2C-OLED</span>
    </div>
    <div class="header-divider"></div>
    <div class="status-pill">
        <div class="status-dot"></div>
        <span class="status-label">SIMULATION ACTIVE</span>
    </div>
    <div class="header-right">
        <button class="hdr-btn hdr-btn-mode" onclick="toggleMode()" id="btnMode">ğŸ“± Mobile</button>
        <button class="hdr-btn hdr-btn-danger" onclick="clearAll()">Clear All</button>
    </div>
</div>

<!-- NAV TABS -->

<div id="ui-top">
    <div class="cat-group">
        <button class="cat-btn" onclick="selectCategory('active', this)">Activos</button>
        <button class="cat-btn" onclick="selectCategory('passive', this)">Pasivos</button>
        <button class="cat-btn" onclick="selectCategory('digital', this)">Digitales</button>
        <button class="cat-btn" onclick="selectCategory('boards', this)">Placas</button>
        <button class="cat-btn" onclick="selectCategory('output_plus', this)">Output+</button>
        <button class="cat-btn" onclick="selectCategory('dev_plus', this)" style="color:rgba(167,139,250,0.6);">Dev+</button>
    </div>
    <div class="cat-group">
        <button class="cat-btn cat-btn-demo" onclick="selectCategory('demos', this)">â˜… Demos</button>
        <button class="cat-btn cat-btn-manual" onclick="toggleManual()">Manual</button>
        <button class="cat-btn cat-btn-manual" onclick="toggleAbout()">About</button>
    </div>
</div>

<!-- SPAWN BAR -->

<div id="ui-sub">
    <span class="sub-hint">â†‘ Selecciona una categorÃ­a</span>
</div>

<div id="canvas-container" oncontextmenu="return false;">

```
<div id="hud-coords">
    <div>X <span id="cx">0</span></div>
    <div>Y <span id="cy">0</span></div>
    <div>Z <span id="cz">1.0</span>Ã—</div>
</div>

<div id="zoom-controls">
    <button class="zoom-btn" onclick="camera.zoom = Math.min(3.0, camera.zoom + 0.2)" title="Zoom In">+</button>
    <div class="zoom-divider"></div>
    <button class="zoom-btn" onclick="camera.zoom = 1.0" style="font-size:9px; letter-spacing:-0.5px;" title="Reset">1:1</button>
    <div class="zoom-divider"></div>
    <button class="zoom-btn" onclick="camera.zoom = Math.max(0.4, camera.zoom - 0.2)" title="Zoom Out">âˆ’</button>
</div>

<canvas id="circuitCanvas"></canvas>
<div id="fx-overlay"></div>

<!-- MODAL -->
<div id="modal">
    <div class="modal-titlebar">
        <div class="modal-accent"></div>
        <div id="m-title">CONFIGURE</div>
        <div id="m-lang-badge" style="display:none; margin-left:auto; font-family:'DM Mono',monospace; font-size:8px; color:var(--cyan); border:1px solid rgba(0,212,255,0.25); padding:1px 7px; border-radius:3px; letter-spacing:1px;">LOG v2.0</div>
    </div>
    <div class="modal-body">
        <div class="modal-field" id="m-val-row">
            <input type="number" id="m-val">
            <span id="m-unit"></span>
        </div>

        <!-- PROFESSIONAL CODE EDITOR -->
        <div class="code-editor-wrap" id="m-code-editor">
            <div class="code-toolbar">
                <span class="code-toolbar-label">RADION 1.1 Â· LOG v2.0</span>
                <button class="code-snippet-btn" onclick="openCodePanel('snippets')" id="tab-snippets" style="color:var(--cyan);border-color:rgba(0,212,255,0.4);">Snippets</button>
                <button class="code-snippet-btn" onclick="openCodePanel('libs')" id="tab-libs">Libs</button>
                <button class="code-snippet-btn" onclick="openCodePanel('demos')" id="tab-demos">Demos</button>
            </div>
            <div id="code-panel" style="display:none; background:rgba(0,0,0,0.5); border-bottom:1px solid var(--glass-border); max-height:120px; overflow-y:auto; padding:6px 8px; flex-wrap:wrap; gap:4px; scrollbar-width:thin;">
            </div>
            <div class="code-body">
                <div class="code-lines" id="m-line-nums"></div>
                <textarea id="m-code-area" spellcheck="false" placeholder="// LOG v2.0 code..." oninput="syncLineNums()" onscroll="syncLineScroll()"></textarea>
            </div>
            <div class="code-statusbar">
                <div class="code-status-item"><div class="code-status-dot"></div><span>LOG v2.0</span></div>
                <div class="code-status-item"><span id="m-line-count">0 lÃ­neas</span></div>
                <div class="code-status-item"><span id="m-char-count">0 chars</span></div>
            </div>
            <div id="log-console">
                <div class="console-header">
                    <span class="console-header-label">â–¸ OUTPUT / CONSOLE</span>
                    <button class="console-clear-btn" onclick="clearConsole()">clear âœ•</button>
                </div>
                <div id="log-console-body"></div>
            </div>
        </div>

        <div class="modal-actions">
            <button class="modal-btn modal-btn-toggle" id="m-toggle" onclick="toggleCompType()" style="display:none;">TYPE: NPN</button>
            <button class="modal-btn modal-btn-save" id="m-btn-validate" onclick="saveCfg()">Save</button>
            <button class="modal-btn" id="m-btn-submit" onclick="submitCfg()" style="display:none; background:rgba(0,230,118,0.12); border-color:rgba(0,230,118,0.35); color:var(--green);">Submit â†‘</button>
            <button class="modal-btn" onclick="closeCfg()">Cancel</button>
            <button class="modal-btn modal-btn-rep" id="m-repair" onclick="repairCfg()" style="display:none;">Repair</button>
        </div>
    </div>
</div>

<!-- MANUAL -->
<div id="manual-screen">
    <div class="manual-header">
        <div class="manual-title-wrap">
            <span class="manual-title">MANUAL</span>
            <span class="manual-badge">SIMULIC PRO</span>
        </div>
        <button class="close-manual" onclick="toggleManual()">Cerrar âœ•</button>
    </div>
    <div class="manual-inner">
        <h4>IntroducciÃ³n</h4>
        <p>Bienvenido a Simulic Pro, un entorno de simulaciÃ³n electrÃ³nica donde la fÃ­sica importa. AquÃ­ puedes crear circuitos complejos, lÃ³gica digital y automatizaciÃ³n.</p>

        <h4>Â¿Por quÃ© se queman mis componentes?</h4>
        <p style="color:var(--red);">Esto no es un error â€” es fÃ­sica.</p>
        <p>Al igual que en la vida real, los componentes tienen lÃ­mites:</p>
        <ul>
            <li>Un <strong>LED</strong> conectado directo a una baterÃ­a de 9V <strong>explotarÃ¡</strong>. Necesita una resistencia (aprox 330Î©).</li>
            <li>Un <strong>Transistor</strong> sin resistencia en la base se quemarÃ¡.</li>
            <li>Si algo dice "BURNED", usa <strong>Ajustar â†’ Reparar</strong>.</li>
        </ul>

        <h4>ProgramaciÃ³n LOG (Radion 1.1)</h4>
        <p>El componente RADION cuenta con pines D1, D2, D3 y un bus I2C (SCL, SDA).</p>
        <ul>
            <li><code>start&lt;</code> / <code>end&gt;</code> â€” Delimitan el programa.</li>
            <li><code>var=D1</code> â€” Asigna pin fÃ­sico a variable.</li>
            <li><code>var;HIGH</code> / <code>var;LOW</code> â€” Controla salida digital.</li>
            <li><code>delay 500</code> â€” Espera en milisegundos.</li>
            <li><code>loop{ ... }</code> â€” Bucle infinito.</li>
            <li><code>if var==HIGH { ... }</code> â€” Condicional de entrada.</li>
        </ul>

        <h4>Variables NumÃ©ricas y AritmÃ©tica</h4>
        <p>Puedes declarar variables numÃ©ricas, operar con ellas y usarlas en condiciones:</p>
        <ul>
            <li><code>contador=0</code> â€” Variable numÃ©rica.</li>
            <li><code>contador=contador+1</code> â€” Suma, resta, multiplicaciÃ³n, divisiÃ³n, mÃ³dulo.</li>
            <li><code>if contador &gt; 5 { ... }</code> â€” Comparaciones: <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code></li>
            <li><code>oled.print contador</code> â€” Muestra el valor de una variable en pantalla.</li>
            <li><code>pin1;HIGH if contador &gt; 0</code> â€” Activar pin con condiciÃ³n inline.</li>
            <li><code>delay velocidad</code> â€” Usar variable numÃ©rica como tiempo de delay.</li>
        </ul>
        <pre>start&lt;
```

pin1=D1
pinBtn=D2
contador=0
velocidad=300
oled.init
oled.println â€œRADION 1.1â€
loop{
pinBtn=D2
if pinBtn==HIGH {
contador=contador+1
pin1;HIGH
delay 100
pin1;LOW
}
if contador > 9 {
contador=0
oled.clear
oled.println â€œRESET!â€
}
oled.clear
oled.print â€œCOUNT: â€œ
oled.print contador
delay velocidad
}
end></pre>

```
        <h4>Pantallas OLED (I2C)</h4>
        <p>Conecta SCLâ†’SCL y SDAâ†’SDA entre Radion y OLED (+ alimentaciÃ³n). Luego:</p>
        <ul>
            <li><code>oled.init</code> â€” Inicializa la pantalla.</li>
            <li><code>oled.print "Texto"</code> â€” Escribe en lÃ­nea actual.</li>
            <li><code>oled.print variable</code> â€” Muestra valor de variable (numÃ©rica o string).</li>
            <li><code>oled.println "Texto"</code> â€” Escribe y salta a nueva lÃ­nea.</li>
            <li><code>oled.clear</code> â€” Limpia la pantalla.</li>
        </ul>
    </div>
</div>

<!-- ABOUT -->
<div id="about-screen">
    <div class="manual-header">
        <div class="manual-title-wrap">
            <span class="manual-title">ABOUT</span>
            <span class="manual-badge">SIMULIC PRO</span>
        </div>
        <button class="close-manual" onclick="toggleAbout()">Cerrar âœ•</button>
    </div>
    <div class="manual-inner">
        <h4>What is Simulic Pro?</h4>
        <p>Simulic Pro is a browser-based electronics circuit simulator built for learning, prototyping, and experimentation. No installations, no dependencies â€” just open it and start building.</p>
        <p>It features a real physics engine that simulates voltage, current, and component limits, meaning components actually burn if you wire them wrong. This is intentional â€” it's how you learn.</p>

        <h4>What can it do?</h4>
        <p>Beyond basic circuits, Simulic Pro includes the <strong>Radion 1.1</strong>, a programmable microcontroller board with its own scripting language called <strong>LOG</strong>. With it you can control digital pins, run loops and conditionals, work with numeric variables, perform arithmetic, and drive I2C OLED displays â€” all inside the simulator.</p>

        <h4>From the developer</h4>
        <p>Hi! Simulic Pro is a solo project, built and maintained by a single developer. Every feature, fix, and improvement comes from genuine passion for making electronics more accessible and fun to learn.</p>
        <p>If you enjoy using it and would like to contribute â€” whether that's ideas, feedback, bug reports, or collaboration â€” you're more than welcome to reach out. The official contact email is listed on the <strong>GitHub repository</strong>.</p>
        <p style="margin-top: 16px; color: var(--cyan); font-family: 'DM Mono', monospace; font-size: 13px; letter-spacing: 1px;">Thank you for your support! ğŸ’™</p>
    </div>
</div>

<!-- CONTEXT MENU -->
<div id="context-menu">
    <div class="ctx-section">ACTIONS</div>
    <div class="ctx-item" onclick="ctxAction('use')"><span class="ctx-icon">â–¶</span>Usar</div>
    <div class="ctx-item" onclick="ctxAction('cfg')"><span class="ctx-icon">âš™</span>Ajustar</div>
    <div class="ctx-item" onclick="ctxAction('rot')"><span class="ctx-icon">â†»</span>Rotar</div>
    <div class="ctx-separator"></div>
    <div class="ctx-item danger" onclick="ctxAction('del')"><span class="ctx-icon">âœ•</span>Borrar</div>
</div>
```

</div>

<!-- Badge de cable activo (mÃ³vil) -->

<div id="cable-badge">ã€œ Toca un nodo para conectar <span id="cable-badge-cancel">âœ• cancelar</span></div>

<!-- MENÃš CONTEXTUAL TOUCH NATIVO -->

<div id="touch-ctx-menu">
    <div class="tcm-item" id="tcm-use">    <span class="tcm-icon">â–¶</span> Usar</div>
    <div class="tcm-item" id="tcm-cable">  <span class="tcm-icon">ã€œ</span> Cable</div>
    <div class="tcm-sep"></div>
    <div class="tcm-item" id="tcm-cfg">    <span class="tcm-icon">âš™</span> Ajustar</div>
    <div class="tcm-item" id="tcm-rot">    <span class="tcm-icon">â†»</span> Rotar</div>
    <div class="tcm-sep"></div>
    <div class="tcm-item tcm-danger" id="tcm-del"><span class="tcm-icon">âœ•</span> Borrar</div>
</div>

<div id="virtual-controls"></div>

<script>
    let isDesktopMode = false;

    function toggleMode() {
        isDesktopMode = !isDesktopMode;
        const body = document.body;
        const btn = document.getElementById('btnMode');
        if (isDesktopMode) {
            body.classList.add('desktop-mode');
            btn.innerText = "ğŸ–¥ï¸ Desktop";
            btn.style.color = "#00e676";
        } else {
            body.classList.remove('desktop-mode');
            btn.innerText = "ğŸ“± Mobile";
            btn.style.color = "";
        }
        resize();
    }

    function toggleManual() {
        const m = document.getElementById('manual-screen');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    }

    function toggleAbout() {
        const m = document.getElementById('about-screen');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    }

    const componentLists = {
        'active': [
            { id: 'BATTERY', label: 'BaterÃ­a' }, { id: 'LED', label: 'LED' },
            { id: 'MOTOR', label: 'Motor' }, { id: 'TRANSISTOR', label: 'Transistor' }, { id: 'RELAY', label: 'RelÃ©' }
        ],
        'passive': [
            { id: 'SWITCH', label: 'Interruptor' }, { id: 'PUSH_BTN', label: 'BotÃ³n' },
            { id: 'RESISTOR', label: 'Resistencia' }, { id: 'CAPACITOR', label: 'Condensador' }
        ],
        'digital': [
            { id: 'RSK90', label: 'Chip RSK90' }, { id: 'AND', label: 'AND' }, { id: 'OR', label: 'OR' },
            { id: 'XOR', label: 'XOR' }, { id: 'NOT', label: 'NOT' }, { id: 'MUX', label: 'MUX' }
        ],
        'boards': [{ id: 'RADION', label: 'Radion 1.1' }],
        'output_plus': [{ id: 'OLED_I2C', label: 'OLED Display' }],
        'dev_plus': [
            { id: 'L298N', label: 'L298N Motor Driver' },
            { id: 'SERVO', label: 'Servomotor SG90' }
        ]
    };

    const demos = {
        'EMPTY':  { label: 'VacÃ­o', func: () => clearAll(true) },
        'BASIC':  { label: 'Electricidad BÃ¡sica', func: () => loadBasicDemo() },
        'LOGIC':  { label: 'Puerta AND', func: () => loadLogicDemo() },
        'MOTOR':  { label: 'Control Motor', func: () => loadMotorDemo() },
        'RADION': { label: 'Radion Blink', func: () => loadRadionDemo() },
        'INPUT':  { label: 'Radion Input', func: () => loadInputDemo() },
        'OLED':   { label: 'Radion OLED', func: () => loadOledDemo() },
        'MDRIVER':{ label: 'Radion + L298N', func: () => loadMotorDriverDemo() },
        'SERVO':  { label: 'Radion + Servo',  func: () => loadServoDemo() }
    };

    function selectCategory(cat, btnElement) {
        document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
        if (btnElement && !btnElement.classList.contains('cat-btn-manual')) btnElement.classList.add('active');
        const sub = document.getElementById('ui-sub');
        sub.innerHTML = '';

        if (cat === 'demos') {
            Object.keys(demos).forEach(key => {
                const d = demos[key];
                const btn = document.createElement('button');
                btn.className = 'spawn-btn';
                btn.innerText = d.label;
                btn.style.color = key === 'EMPTY' ? 'var(--red)' : 'var(--purple)';
                btn.style.borderColor = key === 'EMPTY' ? 'rgba(255,71,87,0.25)' : 'rgba(167,139,250,0.25)';
                btn.onclick = d.func;
                sub.appendChild(btn);
            });
        } else {
            componentLists[cat].forEach(comp => {
                const btn = document.createElement('button');
                btn.className = 'spawn-btn';
                btn.innerText = comp.label;
                btn.onclick = () => spawn(comp.id);
                if (cat === 'digital') btn.style.color = 'var(--cyan)';
                if (comp.id === 'RADION') { btn.style.color = 'var(--green)'; btn.style.borderColor = 'rgba(0,230,118,0.3)'; }
                if (comp.id === 'OLED_I2C') { btn.style.color = 'var(--amber)'; btn.style.borderColor = 'rgba(255,183,0,0.3)'; }
                if (comp.id === 'L298N') { btn.style.color = 'var(--purple)'; btn.style.borderColor = 'rgba(167,139,250,0.3)'; }
                sub.appendChild(btn);
            });
        }
    }

    function connect(c1, pin1, c2, pin2) {
        const n1 = c1.nodes[pin1], n2 = c2.nodes[pin2];
        if (n1 && n2) connections.push({ a: {c:c1, n:n1}, b: {c:c2, n:n2} });
    }

    function loadBasicDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const bat = spawn('BATTERY', -150, -50); const res = spawn('RESISTOR', -20, -100);
        const sw = spawn('SWITCH', -20, 0); const led = spawn('LED', 120, -50);
        connect(bat,0,res,0); connect(res,1,led,0); connect(led,1,sw,1); connect(sw,0,bat,1); sw.closed = true;
    }

    function loadLogicDemo() {
        clearAll(true); camera.x = 0; camera.y = 0;
        const sw1 = spawn('SWITCH', -180, -80); const sw2 = spawn('SWITCH', -180, 20);
        const andGate = spawn('AND', -30, -30); const res = spawn('RESISTOR', 100, -30); res.val = 220;
        const led = spawn('LED', 200, -30); const bat = spawn('BATTERY', -250, 150);
        connect(bat,0,sw1,0); connect(bat,0,sw2,0); connect(sw1,1,andGate,0); connect(sw2,1,andGate,1);
        connect(andGate,2,res,0); connect(res,1,led,0); connect(led,1,bat,1);
    }

    function loadMotorDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const bat = spawn('BATTERY',-120,-50); const res = spawn('RESISTOR',-20,-120); res.val=10;
        const btn = spawn('PUSH_BTN',60,-50); const motor = spawn('MOTOR',60,50);
        connect(bat,0,res,0); connect(res,1,motor,0); connect(motor,1,btn,0); connect(btn,1,bat,1);
    }

    function loadRadionDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const radion = spawn('RADION',-50,-50); const led1 = spawn('LED',150,-80);
        const led2 = spawn('LED',150,20); const bat = spawn('BATTERY',-200,0);
        connect(bat,0,radion,0); connect(bat,1,radion,1); connect(radion,3,led1,0);
        connect(led1,1,radion,2); connect(radion,4,led2,0); connect(led2,1,radion,2);
        radion.code = `start<\npin1=D1\npin2=D2\nloop{\n  pin1;HIGH\n  delay 200\n  pin1;LOW\n  pin2;HIGH\n  delay 200\n  pin2;LOW\n}\nend>`;
        radion.intState = { pc:0, wait:0, vars:{}, parsed:null };
    }

    function loadInputDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const radion = spawn('RADION',-20,-50); const led = spawn('LED',150,-20);
        const btn = spawn('PUSH_BTN',-180,20); const bat = spawn('BATTERY',-250,-100);
        connect(bat,0,radion,0); connect(bat,1,radion,1); connect(bat,0,btn,0);
        connect(btn,1,radion,4); connect(radion,3,led,0); connect(led,1,radion,2);
        radion.code = `start<\npinLed=D1\npinBtn=D2\nloop{\n  if pinBtn==HIGH {\n    pinLed;HIGH\n  }\n  if pinBtn==LOW {\n    pinLed;LOW\n  }\n}\nend>`;
        radion.intState = { pc:0, wait:0, vars:{}, parsed:null };
    }

    function loadOledDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const radion = spawn('RADION',-100,-30);
        const oled   = spawn('OLED_I2C',110,-30);
        const bat    = spawn('BATTERY',-270,-30);
        connect(bat,0,radion,0); connect(bat,1,radion,1);
        connect(bat,0,oled,0);   connect(bat,1,oled,1);
        const radSCL = radion.nodes.findIndex(n=>n.id==='SCL');
        const radSDA = radion.nodes.findIndex(n=>n.id==='SDA');
        const oledSCL = oled.nodes.findIndex(n=>n.id==='SCL');
        const oledSDA = oled.nodes.findIndex(n=>n.id==='SDA');
        connect(radion,radSCL,oled,oledSCL);
        connect(radion,radSDA,oled,oledSDA);
        radion.code = `start<\noled.init\noled.println "HELLO WORLD!"\ndelay 1000\noled.println "RADION 1.1 I2C"\ndelay 1000\noled.println "STATUS: OK"\nloop{\n  delay 500\n  oled.print "."\n}\nend>`;
        radion.intState = { pc:0, wait:0, vars:{}, timers:{}, pinBlink:{}, parsed:null };
    }

    function loadMotorDriverDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const bat    = spawn('BATTERY',   -260,  20);
        const radion = spawn('RADION',     -80, -60);
        const btn    = spawn('PUSH_BTN',  -260, -80);
        const driver = spawn('L298N',       80,  -20);
        const motor  = spawn('MOTOR',      290,  20);
        connect(bat,0,radion,0); connect(bat,1,radion,1);
        connect(bat,0,btn,0); connect(btn,1,radion,5);
        connect(radion,3,driver,2); connect(radion,4,driver,3);
        connect(bat,0,driver,0); connect(bat,1,driver,1);
        connect(driver,4,motor,0); connect(driver,5,motor,1);
        radion.code = `start<\npinBtn=D3\npin1=D1\npin2=D2\nloop{\n  pinBtn=D3\n  if pinBtn==HIGH {\n    pin1;HIGH\n    pin2;LOW\n  }\n  if pinBtn==LOW {\n    pin1;LOW\n    pin2;HIGH\n  }\n}\nend>`;
        radion.intState = { pc:0, wait:0, vars:{}, timers:{}, pinBlink:{}, parsed:null };
    }

    function loadServoDemo() {
        clearAll(true); camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        const bat    = spawn('BATTERY',  -280,  30);
        const radion = spawn('RADION',    -80, -50);
        const oled   = spawn('OLED_I2C',  80, -130);
        const btn1   = spawn('PUSH_BTN', -280, -90);
        const btn2   = spawn('PUSH_BTN', -280,  110);
        const servo  = spawn('SERVO',     140,  30);
        connect(bat,0,radion,0); connect(bat,1,radion,1);
        connect(bat,0,oled,0);   connect(bat,1,oled,1);
        connect(bat,0,servo,0);  connect(bat,1,servo,1);
        connect(bat,0,btn1,0); connect(btn1,1,radion,4);
        connect(bat,0,btn2,0); connect(btn2,1,radion,5);
        const d4idx  = radion.nodes.findIndex(n=>n.id==='D4');
        const sigIdx = servo.nodes.findIndex(n=>n.id==='SIG');
        connect(radion,d4idx,servo,sigIdx);
        const radSCL  = radion.nodes.findIndex(n=>n.id==='SCL');
        const radSDA  = radion.nodes.findIndex(n=>n.id==='SDA');
        const oledSCL = oled.nodes.findIndex(n=>n.id==='SCL');
        const oledSDA = oled.nodes.findIndex(n=>n.id==='SDA');
        connect(radion,radSCL,oled,oledSCL);
        connect(radion,radSDA,oled,oledSDA);
        radion.code = `start<
// Servo con dos botones: subir/bajar angulo
pinUp=D2
pinDown=D3
angulo=90
servo.write(D4,angulo)
oled.init
oled.println "SERVO CTRL"
loop{
  pinUp=D2
  pinDown=D3
  if pinUp==HIGH {
    angulo=angulo+5
    angulo=math.clamp(angulo,0,180)
    servo.write(D4,angulo)
    console.print str.concat("Angulo: ",angulo)
    delay 80
  }
  if pinDown==HIGH {
    angulo=angulo-5
    angulo=math.clamp(angulo,0,180)
    servo.write(D4,angulo)
    console.print str.concat("Angulo: ",angulo)
    delay 80
  }
  oled.clear
  oled.println "SERVO CTRL"
  oled.print "Ang: "
  oled.print angulo
  oled.println " deg"
  oled.draw.bar(angulo,0,180)
  delay 20
}
end>`;
        radion.intState = { pc:0, wait:0, vars:{}, timers:{}, pinBlink:{}, parsed:null };
    }

    selectCategory('active', document.querySelector('.cat-btn'));

    // â”€â”€â”€ ENGINE â”€â”€â”€
    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    let components = [], connections = [];
    const vMouse = { x:0, y:0, speed:4, isDown:false, lastDown:false, moving:{}, selectionMode:false };
    let draggingComp=null, drawingCable=null, rotAnim=0, time=0;
    let targetCfg=null, selectionBox=null, selectedItems=[], camera={x:0,y:0,zoom:1.0};
    let contextTarget=null, isPanning=false;

    function resize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        if (canvas.width === w && canvas.height === h) return;
        canvas.width = w;
        canvas.height = h;
    }
    window.addEventListener('resize', resize);
    if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', resize);
    }
    resize();

    canvas.addEventListener('wheel', (e) => {
        if (!isDesktopMode) return;
        e.preventDefault();
        camera.zoom = Math.min(3.0, Math.max(0.4, camera.zoom + Math.sign(e.deltaY)*-0.1));
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDesktopMode) return;
        if (isPanning) { camera.x -= e.movementX/camera.zoom; camera.y -= e.movementY/camera.zoom; return; }
        const rect = canvas.getBoundingClientRect();
        vMouse.x = ((e.clientX - rect.left)/camera.zoom) + camera.x - (canvas.width/2)/camera.zoom;
        vMouse.y = ((e.clientY - rect.top)/camera.zoom) + camera.y - (canvas.height/2)/camera.zoom;
        if (selectionBox) { selectionBox.w = vMouse.x - selectionBox.x; selectionBox.h = vMouse.y - selectionBox.y; }
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!isDesktopMode) return;
        if (e.button === 1) { e.preventDefault(); isPanning = true; canvas.style.cursor = 'grabbing'; return; }
        if (e.button !== 0) return;
        document.getElementById('context-menu').style.display = 'none';
        let nHit = null;
        components.forEach(c => c.nodes.forEach(n => { if (Math.hypot(c.x+n.x-vMouse.x, c.y+n.y-vMouse.y) < 20) nHit = {c,n}; }));
        if (nHit) { drawingCable = nHit; }
        else {
            let compHit = components.find(c => vMouse.x>c.x && vMouse.x<c.x+c.w && vMouse.y>c.y && vMouse.y<c.y+c.h);
            if (compHit) {
                if (selectedItems.includes(compHit)) draggingComp = {group:true, ref:compHit, ox:vMouse.x, oy:vMouse.y};
                else { selectedItems.forEach(c=>c.selected=false); selectedItems=[]; draggingComp={c:compHit,ox:vMouse.x-compHit.x,oy:vMouse.y-compHit.y}; }
            } else { selectedItems.forEach(c=>c.selected=false); selectedItems=[]; selectionBox={x:vMouse.x,y:vMouse.y,w:0,h:0}; }
        }
    });

    canvas.addEventListener('contextmenu', (e) => {
        if (!isDesktopMode) return;
        e.preventDefault();
        let compHit = components.find(c => vMouse.x>c.x && vMouse.x<c.x+c.w && vMouse.y>c.y && vMouse.y<c.y+c.h);
        if (compHit) {
            contextTarget = compHit;
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block'; menu.style.left = e.clientX+'px'; menu.style.top = e.clientY+'px';
        } else document.getElementById('context-menu').style.display = 'none';
    });

    canvas.addEventListener('mouseup', (e) => {
        if (!isDesktopMode) return;
        if (e.button === 1) { isPanning = false; canvas.style.cursor = 'crosshair'; return; }
        if (drawingCable) {
            let targetHit = null;
            components.forEach(c => c.nodes.forEach(n => { if (c!==drawingCable.c && Math.hypot(c.x+n.x-vMouse.x,c.y+n.y-vMouse.y)<20) targetHit={c,n}; }));
            if (targetHit) connections.push({a:drawingCable,b:targetHit});
            else { const wp=spawn('WAYPOINT'); connections.push({a:drawingCable,b:{c:wp,n:wp.nodes[0]}}); }
        }
        if (selectionBox) { applySelection(); selectionBox=null; }
        draggingComp = drawingCable = null;
    });

    function ctxAction(action) {
        document.getElementById('context-menu').style.display = 'none';
        if (!contextTarget) return;
        if (action==='del') {
            components = components.filter(c=>c!==contextTarget);
            connections = connections.filter(conn=>components.includes(conn.a.c)&&components.includes(conn.b.c));
            if (selectedItems.includes(contextTarget)) selectedItems=[];
        } else if (action==='rot') rotateComponent(contextTarget);
        else if (action==='cfg') openCfg(contextTarget);
        else if (action==='use' && (contextTarget.type==='SWITCH'||contextTarget.type==='PUSH_BTN')) contextTarget.closed = !contextTarget.closed;
        contextTarget = null;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // TOUCH NATIVO MÃ“VIL â€” interacciÃ³n directa en el canvas
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    (function setupMobileTouch() {

        const HOLD_MS    = 440;
        const DRAG_THR   = 8;
        const NODE_HIT   = 26;
        const PINCH_SENS = 0.012;

        let touchCtxTarget = null;

        function toWorld(cx, cy) {
            const rect = canvas.getBoundingClientRect();
            const sx = (cx - rect.left) / camera.zoom;
            const sy = (cy - rect.top)  / camera.zoom;
            const wx = sx + camera.x - (canvas.width  / 2) / camera.zoom;
            const wy = sy + camera.y - (canvas.height / 2) / camera.zoom;
            return { x: wx, y: wy };
        }

        function compAt(wx, wy) {
            const hits = components.filter(c => wx > c.x && wx < c.x+c.w && wy > c.y && wy < c.y+c.h);
            if (!hits.length) return null;
            const sel = hits.find(c => selectedItems.includes(c));
            if (sel) return sel;
            return hits[hits.length - 1];
        }

        function nodeAt(wx, wy) {
            let hit = null;
            components.forEach(c => c.nodes.forEach(n => {
                if (Math.hypot(c.x+n.x-wx, c.y+n.y-wy) < NODE_HIT) hit = {c, n};
            }));
            return hit;
        }

        const fxOverlay = document.getElementById('fx-overlay');

        function spawnRipple(cx, cy) {
            requestAnimationFrame(() => {
                const el = document.createElement('div');
                el.className = 'touch-ripple';
                el.style.left = cx + 'px';
                el.style.top  = cy + 'px';
                fxOverlay.appendChild(el);
                el.addEventListener('animationend', () => el.remove());
            });
        }

        let holdProgressEl = null;
        function spawnHoldProgress(cx, cy) {
            if (holdProgressEl) holdProgressEl.remove();
            requestAnimationFrame(() => {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 52 52');
                svg.setAttribute('width', '52');
                svg.setAttribute('height', '52');
                svg.className = 'hold-progress';
                svg.style.cssText = `left:${cx - 26}px; top:${cy - 26}px; background:transparent;`;
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '26'); circle.setAttribute('cy', '26'); circle.setAttribute('r', '22');
                circle.setAttribute('fill', 'none');
                svg.appendChild(circle);
                fxOverlay.appendChild(svg);
                holdProgressEl = svg;
                svg.addEventListener('animationend', () => { if(holdProgressEl===svg) holdProgressEl=null; svg.remove(); });
            });
        }
        function cancelHoldProgress() {
            if (holdProgressEl) { holdProgressEl.remove(); holdProgressEl = null; }
        }

        function spawnHoldRing(cx, cy) {
            cancelHoldProgress();
            requestAnimationFrame(() => {
                const el = document.createElement('div');
                el.className = 'hold-ring';
                el.style.left = cx + 'px';
                el.style.top  = cy + 'px';
                fxOverlay.appendChild(el);
                el.addEventListener('animationend', () => el.remove());
            });
        }

        const cableBadge = document.getElementById('cable-badge');
        document.getElementById('cable-badge-cancel').addEventListener('click', () => {
            drawingCable = null;
            updateCableBadge();
        });
        function updateCableBadge() {
            drawingCable ? cableBadge.classList.add('visible') : cableBadge.classList.remove('visible');
        }

        const tcmMenu = document.getElementById('touch-ctx-menu');

        function showTCM(cx, cy, comp) {
            touchCtxTarget = comp;
            const menuW = 170, menuH = 220;
            const vw = window.innerWidth, vh = window.innerHeight;
            let mx = cx + 12, my = cy - menuH / 2;
            if (mx + menuW > vw) mx = cx - menuW - 12;
            if (my < 8) my = 8;
            if (my + menuH > vh - 8) my = vh - menuH - 8;
            tcmMenu.style.left = mx + 'px';
            tcmMenu.style.top  = my + 'px';
            tcmMenu.classList.add('visible');
            document.getElementById('tcm-use').style.display =
                (comp && (comp.type==='SWITCH'||comp.type==='PUSH_BTN')) ? 'flex' : 'none';
            document.getElementById('tcm-cable').style.display = comp ? 'flex' : 'none';
        }

        function hideTCM() {
            tcmMenu.classList.remove('visible');
            touchCtxTarget = null;
        }

        document.getElementById('tcm-use').addEventListener('click', () => {
            if (!touchCtxTarget) return hideTCM();
            if (touchCtxTarget.type === 'SWITCH') touchCtxTarget.closed = !touchCtxTarget.closed;
            if (touchCtxTarget.type === 'PUSH_BTN') touchCtxTarget.closed = !touchCtxTarget.closed;
            hideTCM();
        });
        document.getElementById('tcm-cable').addEventListener('click', () => {
            if (!touchCtxTarget) return hideTCM();
            drawingCable = { c: touchCtxTarget, n: touchCtxTarget.nodes[0] };
            vMouse.x = touchCtxTarget.x + touchCtxTarget.nodes[0].x;
            vMouse.y = touchCtxTarget.y + touchCtxTarget.nodes[0].y;
            hideTCM();
            updateCableBadge();
        });
        document.getElementById('tcm-cfg').addEventListener('click', () => {
            if (!touchCtxTarget) return hideTCM();
            const t = touchCtxTarget; hideTCM(); openCfg(t);
        });
        document.getElementById('tcm-rot').addEventListener('click', () => {
            if (!touchCtxTarget) return hideTCM();
            rotateComponent(touchCtxTarget); hideTCM();
        });
        document.getElementById('tcm-del').addEventListener('click', () => {
            if (!touchCtxTarget) return hideTCM();
            components = components.filter(c => c !== touchCtxTarget);
            connections = connections.filter(conn =>
                components.includes(conn.a.c) && components.includes(conn.b.c));
            if (selectedItems.includes(touchCtxTarget)) selectedItems = [];
            hideTCM();
        });

        document.addEventListener('touchstart', (e) => {
            if (!tcmMenu.classList.contains('visible')) return;
            if (!tcmMenu.contains(e.target)) hideTCM();
        }, { passive: true });

        const gestures = new Map();
        let lastPinchDist = null;

        canvas.addEventListener('touchstart', (e) => {
            if (isDesktopMode) return;
            e.preventDefault();
            if (tcmMenu.classList.contains('visible')) { hideTCM(); return; }

            for (const t of e.changedTouches) {
                const w = toWorld(t.clientX, t.clientY);
                const comp   = compAt(w.x, w.y);
                const node   = nodeAt(w.x, w.y);

                const holdProgressTimer = setTimeout(() => spawnHoldProgress(t.clientX, t.clientY), 80);

                const holdTimer = setTimeout(() => {
                    const g = gestures.get(t.identifier);
                    if (!g || g.moved) return;
                    spawnHoldRing(t.clientX, t.clientY);
                    if (g.comp) {
                        selectedItems.forEach(c => c.selected = false); selectedItems = [];
                        showTCM(t.clientX, t.clientY, g.comp);
                    } else {
                        selectionBox = { x: g.wx, y: g.wy, w: 0, h: 0 };
                        g.selecting = true;
                    }
                }, HOLD_MS);

                gestures.set(t.identifier, {
                    startX: t.clientX, startY: t.clientY,
                    wx: w.x, wy: w.y,
                    comp, node,
                    moved: false, selecting: false,
                    dragging: false,
                    holdTimer, holdProgressTimer
                });
            }

            if (e.touches.length === 2) {
                gestures.forEach(g => { clearTimeout(g.holdTimer); g.holdTimer = null; clearTimeout(g.holdProgressTimer); g.holdProgressTimer = null; });
                const t0 = e.touches[0], t1 = e.touches[1];
                lastPinchDist = Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY);
                draggingComp = drawingCable = null;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            if (isDesktopMode) return;
            e.preventDefault();

            if (e.touches.length === 2 && lastPinchDist !== null) {
                const t0 = e.touches[0], t1 = e.touches[1];
                const d = Math.hypot(t0.clientX-t1.clientX, t0.clientY-t1.clientY);
                const delta = d - lastPinchDist;
                camera.zoom = Math.min(3, Math.max(0.25, camera.zoom + delta * PINCH_SENS));
                lastPinchDist = d;
                return;
            }
            lastPinchDist = null;

            for (const t of e.changedTouches) {
                const g = gestures.get(t.identifier);
                if (!g) continue;
                const ddx = t.clientX - g.startX;
                const ddy = t.clientY - g.startY;
                const dist = Math.hypot(ddx, ddy);

                if (!g.moved && dist > DRAG_THR) {
                    g.moved = true;
                    clearTimeout(g.holdTimer);
                    g.holdTimer = null;
                    clearTimeout(g.holdProgressTimer);
                    g.holdProgressTimer = null;
                    cancelHoldProgress();

                    if (g.node && !drawingCable) {
                        drawingCable = g.node;
                        updateCableBadge();
                    } else if (g.comp && !g.node) {
                        g.dragging = true;
                        if (selectedItems.includes(g.comp)) {
                            draggingComp = { group: true, ref: g.comp, ox: g.wx, oy: g.wy };
                        } else {
                            selectedItems.forEach(c => c.selected = false); selectedItems = [];
                            draggingComp = { c: g.comp, ox: g.wx - g.comp.x, oy: g.wy - g.comp.y };
                        }
                    }
                }
                if (!g.moved) continue;

                const w = toWorld(t.clientX, t.clientY);
                vMouse.x = w.x; vMouse.y = w.y;

                if (g.selecting && selectionBox) {
                    selectionBox.w = w.x - selectionBox.x;
                    selectionBox.h = w.y - selectionBox.y;

                } else if (draggingComp && g.dragging) {
                    if (draggingComp.group) {
                        const mvx = w.x - draggingComp.ox;
                        const mvy = w.y - draggingComp.oy;
                        selectedItems.forEach(c => { c.x += mvx; c.y += mvy; });
                        draggingComp.ox = w.x; draggingComp.oy = w.y;
                    } else {
                        draggingComp.c.x = w.x - draggingComp.ox;
                        draggingComp.c.y = w.y - draggingComp.oy;
                    }

                } else if (!g.comp && !g.node && !g.selecting && !drawingCable) {
                    const panX = (t.clientX - (g.lastX || g.startX)) / camera.zoom;
                    const panY = (t.clientY - (g.lastY || g.startY)) / camera.zoom;
                    camera.x -= panX; camera.y -= panY;
                }
                g.lastX = t.clientX; g.lastY = t.clientY;
            }
        }, { passive: false });

        function onTouchEnd(e) {
            if (isDesktopMode) return;
            lastPinchDist = null;

            for (const t of e.changedTouches) {
                const g = gestures.get(t.identifier);
                if (!g) continue;
                clearTimeout(g.holdTimer);
                clearTimeout(g.holdProgressTimer);
                cancelHoldProgress();

                const w = toWorld(t.clientX, t.clientY);

                if (!g.moved) {
                    // â”€â”€ TAP puro â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
                    spawnRipple(t.clientX, t.clientY);

                    if (g.node) {
                        if (!drawingCable) {
                            drawingCable = g.node;
                        } else if (drawingCable.c !== g.node.c) {
                            connections.push({ a: drawingCable, b: g.node });
                            drawingCable = null;
                        }
                        updateCableBadge();

                    } else if (g.comp) {
                        if (drawingCable) {
                            let closest = null, minD = Infinity;
                            g.comp.nodes.forEach(n => {
                                const d = Math.hypot(g.comp.x+n.x-w.x, g.comp.y+n.y-w.y);
                                if (d < minD) { minD = d; closest = { c: g.comp, n }; }
                            });
                            if (closest && closest.c !== drawingCable.c) {
                                connections.push({ a: drawingCable, b: closest });
                            }
                            drawingCable = null;
                            updateCableBadge();

                        } else if (g.comp.type === 'PUSH_BTN') {
                            g.comp.closed = true;
                            setTimeout(() => { g.comp.closed = false; }, 180);

                        } else if (g.comp.type === 'SWITCH') {
                            g.comp.closed = !g.comp.closed;

                        } else {
                            selectedItems.forEach(c => c.selected = false);
                            selectedItems = [];
                        }

                    } else {
                        if (drawingCable) {
                            const wp = spawn('WAYPOINT', w.x, w.y);
                            connections.push({ a: drawingCable, b: { c: wp, n: wp.nodes[0] } });
                            drawingCable = { c: wp, n: wp.nodes[0] };
                            updateCableBadge();
                        } else {
                            selectedItems.forEach(c => c.selected = false);
                            selectedItems = [];
                        }
                    }

                } else if (g.selecting && selectionBox) {
                    applySelection(); selectionBox = null;

                } else if (drawingCable && g.moved) {
                    const targetNode = nodeAt(w.x, w.y);
                    if (targetNode && targetNode.c !== drawingCable.c) {
                        connections.push({ a: drawingCable, b: targetNode });
                    } else {
                        const wp = spawn('WAYPOINT', w.x, w.y);
                        connections.push({ a: drawingCable, b: { c: wp, n: wp.nodes[0] } });
                    }
                    drawingCable = null;
                    updateCableBadge();
                }

                draggingComp = null;
                gestures.delete(t.identifier);
            }
        }

        canvas.addEventListener('touchend',    onTouchEnd, { passive: false });
        canvas.addEventListener('touchcancel', onTouchEnd, { passive: false });

    })();

    const clearAllMovement = () => { vMouse.moving = {}; };
    window.addEventListener('blur', clearAllMovement);

    function clearAll(force=false) {
        if(force||confirm("Â¿Borrar todo?")) { components=[]; connections=[]; selectedItems=[]; drawingCable=null; }
    }

    function applySelection() {
        if(!selectionBox)return;
        let bx=selectionBox.w>0?selectionBox.x:selectionBox.x+selectionBox.w;
        let by=selectionBox.h>0?selectionBox.y:selectionBox.y+selectionBox.h;
        let bw=Math.abs(selectionBox.w); let bh=Math.abs(selectionBox.h);
        components.filter(c=>c.x+c.w>bx&&c.x<bx+bw&&c.y+c.h>by&&c.y<by+bh).forEach(c=>{if(!selectedItems.includes(c)){c.selected=true;selectedItems.push(c);}});
    }

    function distToSegment(p,v,w) {
        const l2=(w.x-v.x)**2+(w.y-v.y)**2;
        if(l2===0)return Math.hypot(p.x-v.x,p.y-v.y);
        let t=((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2;
        t=Math.max(0,Math.min(1,t));
        return Math.hypot(p.x-(v.x+t*(w.x-v.x)),p.y-(v.y+t*(w.y-v.y)));
    }

    function rotateComponent(c) {
        c.rotation=(c.rotation+1)%4;
        const cx=c.w/2, cy=c.h/2;
        c.nodes.forEach(n=>{const dx=n.x-cx,dy=n.y-cy;n.x=cx-dy;n.y=cy+dx;});
        [c.w,c.h]=[c.h,c.w];
    }

    // â”€â”€ CODE EDITOR HELPERS â”€â”€
    function syncLineNums() {
        const ta = document.getElementById('m-code-area');
        const ln = document.getElementById('m-line-nums');
        const lines = ta.value.split('\n');
        ln.innerHTML = lines.map((_,i) => `<div class="line-num">${i+1}</div>`).join('');
        document.getElementById('m-line-count').textContent = lines.length + ' lÃ­neas';
        document.getElementById('m-char-count').textContent = ta.value.length + ' chars';
    }
    function syncLineScroll() {
        const ta = document.getElementById('m-code-area');
        document.getElementById('m-line-nums').scrollTop = ta.scrollTop;
    }

    // â”€â”€ CONSOLA LOG â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let consoleOwner = null;

    function logConsole(msg, type) {
        const body = document.getElementById('log-console-body');
        if (!body) return;
        const now = new Date();
        const ts = now.toTimeString().slice(0,8);
        const line = document.createElement('div');
        line.className = `console-line log-${type || 'print'}`;
        const prefix = type === 'error' ? `[ERR ${ts}] ` :
                       type === 'warn'  ? `[WRN ${ts}] ` :
                       type === 'init'  ? '' :
                       type === 'dim'   ? `[LOG ${ts}] ` :
                                          `[OUT ${ts}] `;
        line.textContent = prefix + msg;
        body.appendChild(line);
        const cons = document.getElementById('log-console');
        cons.scrollTop = cons.scrollHeight;
    }

    function clearConsole() {
        const body = document.getElementById('log-console-body');
        if (body) body.innerHTML = '';
        logConsole('LOG v2.0  Â·  Radion 1.1  Â·  Simulic Pro', 'init');
        logConsole('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', 'dim');
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOG v2.0 â€” SNIPPETS, LIBRERÃAS Y DEMOS DE CÃ“DIGO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const LOG_SNIPPETS = [
        { label:'loop{}',    code:'\nloop{\n  \n}' },
        { label:'if/else',   code:'\nif condicion {\n  \n} else {\n  \n}' },
        { label:'while{}',   code:'\nwhile condicion {\n  \n}' },
        { label:'for',       code:'\nfor i=0 to 10 {\n  \n}' },
        { label:'delay',     code:'\ndelay 500' },
        { label:'pin HIGH',  code:'\npin1;HIGH' },
        { label:'pin LOW',   code:'\npin1;LOW' },
        { label:'toggle',    code:'\ntoggle pin1' },
        { label:'print',     code:'\noled.print "Texto"' },
        { label:'println',   code:'\noled.println "Texto"' },
        { label:'oled.init', code:'\noled.init\noled.clear\noled.println "RADION 2.0"' },
        { label:'math.abs',  code:'\nresult=math.abs(valor)' },
        { label:'math.max',  code:'\nresult=math.max(a,b)' },
        { label:'math.min',  code:'\nresult=math.min(a,b)' },
        { label:'math.map',  code:'\nresult=math.map(val,0,100,0,255)' },
        { label:'timer.set', code:'\ntimer.set(t1,1000)' },
        { label:'timer.check',code:'\nif timer.check(t1) {\n  \n}' },
        { label:'str.concat',code:'\nmsg=str.concat("Valor: ",contador)' },
        { label:'str.len',   code:'\nn=str.len(texto)' },
        { label:'pin.read',  code:'\nval=pin.read(D1)' },
        { label:'console.print', code:'\nconsole.print "mensaje"' },
        { label:'console.warn',  code:'\nconsole.warn "aviso"' },
        { label:'console.error', code:'\nconsole.error "error"' },
        { label:'console.info',  code:'\nconsole.info "info"' },
        { label:'console.clear', code:'\nconsole.clear' },
    ];

    const LOG_LIBS = {
        'math': {
            desc: 'Funciones matemÃ¡ticas avanzadas',
            color: 'rgba(0,212,255,0.7)',
            snippets: [
                { label:'abs(x)',         code:'\nresult=math.abs(x)' },
                { label:'max(a,b)',        code:'\nresult=math.max(a,b)' },
                { label:'min(a,b)',        code:'\nresult=math.min(a,b)' },
                { label:'pow(b,e)',        code:'\nresult=math.pow(base,exp)' },
                { label:'sqrt(x)',         code:'\nresult=math.sqrt(x)' },
                { label:'floor(x)',        code:'\nresult=math.floor(x)' },
                { label:'ceil(x)',         code:'\nresult=math.ceil(x)' },
                { label:'round(x)',        code:'\nresult=math.round(x)' },
                { label:'clamp(v,lo,hi)',  code:'\nresult=math.clamp(valor,0,100)' },
                { label:'map(v,i0,i1,o0,o1)', code:'\nresult=math.map(val,0,1023,0,255)' },
                { label:'random(lo,hi)',   code:'\nresult=math.random(1,100)' },
            ]
        },
        'str': {
            desc: 'ManipulaciÃ³n de strings',
            color: 'rgba(0,230,118,0.7)',
            snippets: [
                { label:'concat(a,b)',     code:'\nmsg=str.concat("Val:",numero)' },
                { label:'len(s)',          code:'\nn=str.len(texto)' },
                { label:'upper(s)',        code:'\nmsg=str.upper(texto)' },
                { label:'lower(s)',        code:'\nmsg=str.lower(texto)' },
                { label:'repeat(s,n)',     code:'\nmsg=str.repeat("*",10)' },
                { label:'substr(s,i,n)',   code:'\nmsg=str.substr(texto,0,4)' },
            ]
        },
        'timer': {
            desc: 'Temporizadores no bloqueantes',
            color: 'rgba(255,183,0,0.7)',
            snippets: [
                { label:'timer.set(id,ms)',   code:'\ntimer.set(t1,1000)' },
                { label:'timer.check(id)',    code:'\nif timer.check(t1) {\n  // se dispara cada 1000ms\n}' },
                { label:'timer.reset(id)',    code:'\ntimer.reset(t1)' },
                { label:'timer.elapsed(id)',  code:'\nms=timer.elapsed(t1)' },
            ]
        },
        'pin': {
            desc: 'Control avanzado de pines',
            color: 'rgba(167,139,250,0.7)',
            snippets: [
                { label:'pin.read(D1)',       code:'\nval=pin.read(D1)' },
                { label:'pin.write(D1,H)',    code:'\npin.write(D1,HIGH)' },
                { label:'pin.toggle(D1)',     code:'\npin.toggle(D1)' },
                { label:'pin.pulse(D1,ms)',   code:'\npin.pulse(D1,100)' },
                { label:'pin.blink(D1,ms)',   code:'\npin.blink(D1,200)' },
                { label:'pin.off(D1)',        code:'\npin.off(D1)' },
            ]
        },
        'oled': {
            desc: 'Control completo de pantalla OLED',
            color: 'rgba(255,100,100,0.7)',
            snippets: [
                { label:'oled.init',          code:'\noled.init' },
                { label:'oled.clear',         code:'\noled.clear' },
                { label:'oled.print "txt"',   code:'\noled.print "Texto"' },
                { label:'oled.println "txt"', code:'\noled.println "Texto"' },
                { label:'oled.print var',     code:'\noled.print variable' },
                { label:'oled.draw.bar',      code:'\noled.draw.bar(valor,0,100)' },
                { label:'oled.setCursor',     code:'\noled.setCursor(0,1)' },
                { label:'oled.printAt',       code:'\noled.printAt(0,2,"Linea 3")' },
            ]
        },
        'console': {
            desc: 'Salida a la consola LOG del editor',
            color: 'rgba(0,212,255,0.7)',
            snippets: [
                { label:'console.print "s"',   code:'\nconsole.print "mensaje"' },
                { label:'console.print var',   code:'\nconsole.print variable' },
                { label:'console.println "s"', code:'\nconsole.println "mensaje"' },
                { label:'console.info "s"',    code:'\nconsole.info "info"' },
                { label:'console.warn "s"',    code:'\nconsole.warn "advertencia"' },
                { label:'console.error "s"',   code:'\nconsole.error "error"' },
                { label:'console.clear',       code:'\nconsole.clear' },
            ]
        },
        'servo': {
            desc: 'Control de servomotor SG90 vÃ­a D4',
            color: 'rgba(0,212,255,0.85)',
            snippets: [
                { label:'servo.write(D4,90)',  code:'\nservo.write(D4,90)' },
                { label:'servo.write(D4,0)',   code:'\nservo.write(D4,0)' },
                { label:'servo.write(D4,180)', code:'\nservo.write(D4,180)' },
                { label:'servo.read(D4)',      code:'\nang=servo.read(D4)' },
                { label:'servo sweep',         code:'\nfor ang=0 to 180 {\n  servo.write(D4,ang)\n  delay 15\n}' },
            ]
        },
    };

    const LOG_DEMOS = [
        {
            label: 'ğŸ”´ Blink simple',
            code: `start<
pin1=D1
loop{
  pin1;HIGH
  delay 500
  pin1;LOW
  delay 500
}
end>`
        },
        {
            label: 'ğŸŸ¢ Blink doble alternado',
            code: `start<
pin1=D1
pin2=D2
loop{
  pin1;HIGH
  pin2;LOW
  delay 300
  pin1;LOW
  pin2;HIGH
  delay 300
}
end>`
        },
        {
            label: 'ğŸ”µ Contador OLED',
            code: `start<
pin1=D1
contador=0
oled.init
oled.println "CONTADOR"
loop{
  contador=contador+1
  oled.clear
  oled.println "CONTADOR LOG"
  oled.print "Val: "
  oled.println contador
  if contador > 99 {
    contador=0
    oled.println "RESET!"
    delay 500
  }
  delay 300
}
end>`
        },
        {
            label: 'ğŸŸ¡ SemÃ¡foro',
            code: `start<
pinR=D1
pinG=D2
pinA=D3
oled.init
loop{
  pinR;HIGH
  pinG;LOW
  pinA;LOW
  oled.clear
  oled.println "SEMAFORO"
  oled.println ">>> ROJO"
  delay 2000
  pinR;LOW
  pinA;HIGH
  oled.clear
  oled.println "SEMAFORO"
  oled.println ">>> AMBAR"
  delay 800
  pinA;LOW
  pinG;HIGH
  oled.clear
  oled.println "SEMAFORO"
  oled.println ">>> VERDE"
  delay 2000
}
end>`
        },
        {
            label: 'âš¡ Motor con botÃ³n',
            code: `start<
pinBtn=D3
pin1=D1
pin2=D2
oled.init
oled.println "MOTOR CTRL"
loop{
  pinBtn=D3
  if pinBtn==HIGH {
    pin1;HIGH
    pin2;LOW
    oled.clear
    oled.println "MOTOR CTRL"
    oled.println "DIR: FWD >>>"
  }
  if pinBtn==LOW {
    pin1;LOW
    pin2;HIGH
    oled.clear
    oled.println "MOTOR CTRL"
    oled.println "DIR: REV <<<"
  }
  delay 50
}
end>`
        },
        {
            label: 'ğŸ“Š Barra de progreso OLED',
            code: `start<
progreso=0
oled.init
loop{
  progreso=progreso+5
  if progreso > 100 {
    progreso=0
  }
  oled.clear
  oled.println "PROGRESS:"
  oled.print "["
  oled.print math.map(progreso,0,100,0,10)
  oled.println "] "
  oled.print progreso
  oled.println "%"
  delay 200
}
end>`
        },
        {
            label: 'â± Timer no bloqueante',
            code: `start<
pin1=D1
pin2=D2
oled.init
timer.set(t1,1000)
timer.set(t2,300)
contador=0
loop{
  if timer.check(t1) {
    contador=contador+1
    oled.clear
    oled.println "DUAL TIMER"
    oled.print "Seg: "
    oled.println contador
    timer.reset(t1)
  }
  if timer.check(t2) {
    toggle pin1
    timer.reset(t2)
  }
  delay 10
}
end>`
        },
        {
            label: 'ğŸ”¢ Fibonacci',
            code: `start<
oled.init
a=0
b=1
oled.println "FIBONACCI"
loop{
  oled.clear
  oled.println "FIBONACCI"
  oled.print "A="
  oled.println a
  oled.print "B="
  oled.println b
  temp=a+b
  a=b
  b=temp
  if b > 999 {
    a=0
    b=1
    delay 1000
  }
  delay 700
}
end>`
        },
        {
            label: 'ğŸ› PWM simulado (blink variable)',
            code: `start<
pin1=D1
velocidad=100
paso=50
oled.init
loop{
  pin1;HIGH
  delay velocidad
  pin1;LOW
  delay velocidad
  velocidad=velocidad+paso
  if velocidad > 900 {
    paso=math.abs(paso)*-1
  }
  if velocidad < 100 {
    paso=math.abs(paso)
    velocidad=100
  }
  oled.clear
  oled.println "PWM SIM"
  oled.print "Speed: "
  oled.println velocidad
}
end>`
        },
        {
            label: 'ğŸ” CÃ³digo secreto (3 pines)',
            code: `start<
pinA=D1
pinB=D2
pinC=D3
intentos=0
oled.init
oled.println "ACCESS CTRL"
oled.println "BTN D1+D2"
loop{
  pinA=D1
  pinB=D2
  pinC=D3
  if pinA==HIGH {
    if pinB==HIGH {
      if pinC==LOW {
        oled.clear
        oled.println "ACCESS OK!"
        pinC;HIGH
        delay 1000
        pinC;LOW
        intentos=0
      }
    }
  }
  if pinA==HIGH {
    if pinB==LOW {
      intentos=intentos+1
      oled.clear
      oled.println "ACCESO DENEGADO"
      oled.print "Intentos: "
      oled.println intentos
      delay 500
    }
  }
  delay 100
}
end>`
        },
        {
            label: 'ğŸ“ˆ Rampa de conteo',
            code: `start<
pin1=D1
pin2=D2
n=0
dir=1
oled.init
loop{
  n=n+dir
  if n >= 10 {
    dir=math.abs(dir)*-1
    pin2;HIGH
    pin1;LOW
  }
  if n <= 0 {
    dir=math.abs(dir)
    pin1;HIGH
    pin2;LOW
    n=0
  }
  oled.clear
  oled.println "RAMPA"
  oled.draw.bar(n,0,10)
  oled.print " "
  oled.println n
  delay 150
}
end>`
        },
        {
            label: 'ğŸŒ¡ Simulador de temperatura',
            code: `start<
temp=20
oled.init
loop{
  temp=temp+math.random(-1,2)
  temp=math.clamp(temp,15,40)
  oled.clear
  oled.println "TEMP SENSOR"
  oled.print "Temp: "
  oled.print temp
  oled.println " C"
  if temp > 35 {
    oled.println "! ALERTA ALTA"
    pin1=D1
    pin1;HIGH
  }
  if temp < 35 {
    pin1=D1
    pin1;LOW
  }
  delay 600
}
end>`
        },
        {
            label: 'ğŸ–¥ Debug con consola',
            code: `start<
console.print "=== RADION BOOT ==="
console.info "LOG v2.0 iniciado"
pin1=D1
contador=0
loop{
  pinBtn=D3
  if pinBtn==HIGH {
    contador=contador+1
    console.print str.concat("BTN press #",contador)
    pin1;HIGH
    if contador > 5 {
      console.warn "Muchas pulsaciones!"
    }
    delay 200
    pin1;LOW
  }
  if contador > 9 {
    console.error "Limite alcanzado, reset"
    contador=0
  }
  delay 50
}
end>`
        },
    ];

    let currentCodePanel = null;

    function openCodePanel(tab) {
        const panel = document.getElementById('code-panel');
        const tabs = ['snippets','libs','demos'];
        tabs.forEach(t => {
            const btn = document.getElementById('tab-'+t);
            if(btn){ btn.style.color=''; btn.style.borderColor=''; }
        });
        const activeBtn = document.getElementById('tab-'+tab);
        if(activeBtn){ activeBtn.style.color='var(--cyan)'; activeBtn.style.borderColor='rgba(0,212,255,0.4)'; }

        if (currentCodePanel === tab) {
            panel.style.display = 'none';
            currentCodePanel = null;
            return;
        }
        currentCodePanel = tab;
        panel.style.display = 'flex';
        panel.innerHTML = '';

        if (tab === 'snippets') {
            LOG_SNIPPETS.forEach(s => {
                const btn = document.createElement('button');
                btn.className = 'code-snippet-btn';
                btn.innerText = s.label;
                btn.onclick = () => { insertCode(s.code); };
                panel.appendChild(btn);
            });
        } else if (tab === 'libs') {
            Object.keys(LOG_LIBS).forEach(libKey => {
                const lib = LOG_LIBS[libKey];
                const section = document.createElement('div');
                section.style.cssText = 'width:100%; margin-bottom:6px;';
                section.innerHTML = `<div style="font-family:'DM Mono',monospace;font-size:8px;color:${lib.color};letter-spacing:1px;margin-bottom:3px;">â–¸ ${libKey.toUpperCase()} â€” ${lib.desc}</div>`;
                const row = document.createElement('div');
                row.style.cssText = 'display:flex;flex-wrap:wrap;gap:3px;';
                lib.snippets.forEach(s => {
                    const btn = document.createElement('button');
                    btn.className = 'code-snippet-btn';
                    btn.innerText = s.label;
                    btn.style.color = lib.color;
                    btn.style.borderColor = lib.color.replace('0.7','0.3');
                    btn.onclick = () => { insertCode(s.code); };
                    row.appendChild(btn);
                });
                section.appendChild(row);
                panel.appendChild(section);
            });
        } else if (tab === 'demos') {
            LOG_DEMOS.forEach(d => {
                const btn = document.createElement('button');
                btn.className = 'code-snippet-btn';
                btn.innerText = d.label;
                btn.style.cssText = 'color:var(--purple);border-color:rgba(167,139,250,0.3);padding:3px 10px;font-size:9px;';
                btn.onclick = () => {
                    document.getElementById('m-code-area').value = d.code;
                    syncLineNums();
                    panel.style.display = 'none';
                    currentCodePanel = null;
                };
                panel.appendChild(btn);
            });
        }
    }

    function insertCode(code) {
        const ta = document.getElementById('m-code-area');
        const pos = ta.selectionStart;
        ta.value = ta.value.slice(0, pos) + code + ta.value.slice(pos);
        ta.selectionStart = ta.selectionEnd = pos + code.length;
        ta.focus();
        syncLineNums();
    }

    function insertSnippet(type) {
        const map = { 'loop':'\nloop{\n  \n}', 'delay':'\ndelay 500', 'if':'\nif condicion {\n  \n}', 'oled':'\noled.init\noled.clear\noled.println "Hola"' };
        insertCode(map[type] || '');
    }

    function openCfg(c) {
        targetCfg=c;
        const modal = document.getElementById('modal');
        modal.style.display='block';
        document.getElementById('m-title').innerText=c.type;
        const isBRC=c.type==='BATTERY'||c.type==='RESISTOR'||c.type==='CAPACITOR';
        document.getElementById('m-val-row').style.display=isBRC?'flex':'none';
        document.getElementById('m-val').style.display=isBRC?'block':'none';
        if(isBRC)document.getElementById('m-val').value=c.val||0;
        let unit=''; if(c.type==='BATTERY')unit='V'; else if(c.type==='RESISTOR')unit='Î©'; else if(c.type==='CAPACITOR')unit='ÂµF';
        document.getElementById('m-unit').innerText=unit;
        document.getElementById('m-repair').style.display=c.burned?'inline-flex':'none';
        const tog=document.getElementById('m-toggle');
        if(c.type==='TRANSISTOR'){tog.style.display='inline-flex';tog.innerText='TYPE: '+c.mode;}else tog.style.display='none';
        const editor=document.getElementById('m-code-editor');
        const badge=document.getElementById('m-lang-badge');
        if(c.type==='RADION'){
            editor.style.display='flex';
            badge.style.display='block';
            modal.classList.add('code-mode');
            document.getElementById('m-code-area').value=c.code;
            c.intState={pc:0,wait:0,vars:{},timers:{},pinBlink:{},parsed:null};
            consoleOwner = c;
            clearConsole();
            document.getElementById('m-btn-validate').style.display='inline-flex';
            document.getElementById('m-btn-submit').style.display='inline-flex';
            setTimeout(syncLineNums, 50);
        } else {
            editor.style.display='none';
            badge.style.display='none';
            modal.classList.remove('code-mode');
            document.getElementById('m-btn-validate').style.display='inline-flex';
            document.getElementById('m-btn-submit').style.display='none';
        }
    }

    function toggleCompType() {
        if(targetCfg&&targetCfg.type==='TRANSISTOR'){
            targetCfg.mode=targetCfg.mode==='NPN'?'PNP':'NPN';
            document.getElementById('m-toggle').innerText='TYPE: '+targetCfg.mode;
        }
    }

    function closeCfg(){
        document.getElementById('modal').style.display='none';
        document.getElementById('modal').classList.remove('code-mode');
        targetCfg=null;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // LOG VALIDATOR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function validateLOG(code) {
        const errors   = [];
        const warnings = [];
        const lines    = code.split('\n');

        const KNOWN_LIBS   = ['math','str','timer','pin','oled','console','servo'];
        const KNOWN_MATH   = ['abs','max','min','pow','sqrt','floor','ceil','round','clamp','map','random','sin','cos','pi'];
        const KNOWN_STR    = ['concat','len','upper','lower','repeat','substr','indexOf','replace','trim','num'];
        const KNOWN_TIMER  = ['set','check','reset','elapsed','remaining'];
        const KNOWN_PIN    = ['read','write','toggle','pulse','blink','stopBlink','off'];
        const KNOWN_OLED   = ['init','clear','print','println','draw','setCursor','printAt','scroll','invert'];
        const KNOWN_CONS   = ['print','println','warn','error','info','clear'];
        const KNOWN_SERVO  = ['write','read'];
        const KNOWN_LIB_FNS = { math:KNOWN_MATH, str:KNOWN_STR, timer:KNOWN_TIMER, pin:KNOWN_PIN, oled:KNOWN_OLED, console:KNOWN_CONS, servo:KNOWN_SERVO };

        const KEYWORDS     = ['loop','while','for','if','else','delay','toggle','print','println','start<','end>','console','oled','pin','math','str','timer'];
        const VALID_PINS   = ['D1','D2','D3','D4','A1'];

        const trimmed = code.trim();
        if (!trimmed.startsWith('start<')) {
            errors.push({ line: 1, msg: 'Falta "start<" al inicio del programa' });
        }
        if (!trimmed.endsWith('end>')) {
            errors.push({ line: lines.length, msg: 'Falta "end>" al final del programa' });
        }

        let braceCount = 0;
        let lastOpenLine = -1;
        for (let i = 0; i < lines.length; i++) {
            const l = lines[i].trim();
            if (l.endsWith('{')) { braceCount++; lastOpenLine = i + 1; }
            if (l === '}') braceCount--;
            if (braceCount < 0) {
                errors.push({ line: i + 1, msg: 'Llave de cierre "}" sin apertura correspondiente' });
                braceCount = 0;
            }
        }
        if (braceCount > 0) {
            errors.push({ line: lastOpenLine, msg: `Bloque abierto sin cerrar (falta ${braceCount} "}")` });
        }

        const declaredVars = new Set();

        for (let i = 0; i < lines.length; i++) {
            const raw  = lines[i];
            const l    = raw.trim();
            const lnum = i + 1;

            if (!l || l.startsWith('//') || l === 'start<' || l === 'end>' || l === '}' || l === 'else {' || l === 'else{') continue;

            if (l.startsWith('delay ')) {
                const arg = l.slice(6).trim();
                if (!arg) errors.push({ line: lnum, msg: '"delay" necesita un argumento: delay 500' });
                else if (isNaN(parseFloat(arg)) && !declaredVars.has(arg)) {
                    warnings.push({ line: lnum, msg: `"delay ${arg}": variable "${arg}" no declarada antes de este punto` });
                }
                continue;
            }

            if (l.startsWith('toggle ')) {
                const arg = l.slice(7).trim();
                if (!VALID_PINS.includes(arg) && !declaredVars.has(arg)) {
                    errors.push({ line: lnum, msg: `"toggle ${arg}": "${arg}" no es un pin ni variable declarada` });
                }
                continue;
            }

            if (l.startsWith('loop{') || l === 'loop{') continue;
            if (l.startsWith('loop ')) continue;
            if (l.startsWith('while ')) {
                if (!l.endsWith('{')) errors.push({ line: lnum, msg: '"while" debe terminar con "{"' });
                continue;
            }
            if (l.startsWith('for ')) {
                const m = l.match(/^for\s+(\w+)=(.+?)\s+to\s+(.+?)\s*\{$/);
                if (!m) errors.push({ line: lnum, msg: 'Sintaxis de "for" incorrecta. Usa: for i=0 to 10 {' });
                else declaredVars.add(m[1]);
                continue;
            }
            if (l.startsWith('if ')) {
                if (!l.endsWith('{')) errors.push({ line: lnum, msg: '"if" debe terminar con "{"' });
                continue;
            }

            const libCallMatch = l.match(/^(math|str|timer|pin|oled|console|servo)\.([\w.]+)\(?/);
            if (libCallMatch) {
                const lib = libCallMatch[1];
                const fn  = libCallMatch[2].split('(')[0].split('.')[0];
                const known = KNOWN_LIB_FNS[lib];
                if (known && !known.includes(fn)) {
                    errors.push({ line: lnum, msg: `FunciÃ³n desconocida "${lib}.${fn}()"` });
                }
                continue;
            }

            if (l.includes(';')) {
                const parts   = l.split(';');
                const varName = parts[0].trim();
                const rest    = parts[1] ? parts[1].trim() : '';
                const inlineMatch = rest.match(/^(HIGH|LOW)\s+if\s+(.+)$/);
                const stateStr = inlineMatch ? inlineMatch[1] : rest;
                if (stateStr !== 'HIGH' && stateStr !== 'LOW') {
                    errors.push({ line: lnum, msg: `Estado invÃ¡lido "${stateStr}" â€” usa HIGH o LOW` });
                }
                if (!VALID_PINS.includes(varName) && !declaredVars.has(varName)) {
                    warnings.push({ line: lnum, msg: `Pin "${varName}" no declarado. Â¿Olvidaste "${varName}=D1"?` });
                }
                continue;
            }

            if (l.includes('=') && !l.startsWith('if ') && !l.startsWith('while ') && !l.startsWith('for ')) {
                const eqIdx  = l.indexOf('=');
                const vName  = l.slice(0, eqIdx).trim();
                const expr   = l.slice(eqIdx + 1).trim();

                if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(vName)) {
                    errors.push({ line: lnum, msg: `Nombre de variable invÃ¡lido: "${vName}"` });
                    continue;
                }

                declaredVars.add(vName);

                if (!expr) {
                    errors.push({ line: lnum, msg: `AsignaciÃ³n vacÃ­a en "${vName} ="` });
                    continue;
                }

                const exprLibMatch = expr.match(/^(math|str|timer|pin|console|servo)\.([\w]+)\(/);
                if (exprLibMatch) {
                    const lib = exprLibMatch[1];
                    const fn  = exprLibMatch[2];
                    const known = KNOWN_LIB_FNS[lib];
                    if (known && !known.includes(fn)) {
                        errors.push({ line: lnum, msg: `FunciÃ³n desconocida "${lib}.${fn}()"` });
                    }
                    continue;
                }

                if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(expr)) {
                    const isKnown = VALID_PINS.includes(expr) || expr==='HIGH' || expr==='LOW' || expr==='true' || expr==='false' || expr==='PI' || declaredVars.has(expr) || KEYWORDS.some(k=>expr.startsWith(k));
                    if (!isKnown) {
                        warnings.push({ line: lnum, msg: `"${expr}" parece una variable no declarada` });
                    }
                }
                continue;
            }

            const isBlock   = l.endsWith('{');
            const isKnownKW = KEYWORDS.some(k => l.startsWith(k));
            if (!isBlock && !isKnownKW && l !== '}') {
                if (!/^[a-zA-Z_]/.test(l)) continue;
                errors.push({ line: lnum, msg: `InstrucciÃ³n no reconocida: "${l.length > 30 ? l.slice(0,30)+'â€¦' : l}"` });
            }
        }

        return { errors, warnings };
    }

    function saveCfg(){
        if(!targetCfg) return;

        if(targetCfg.type==='BATTERY'||targetCfg.type==='RESISTOR'||targetCfg.type==='CAPACITOR'){
            targetCfg.val=Math.max(0.1,parseFloat(document.getElementById('m-val').value)||0);
            closeCfg();
            return;
        }

        if(targetCfg.type==='RADION'){
            const code = document.getElementById('m-code-area').value;
            const { errors, warnings } = validateLOG(code);
            clearConsole();
            if (errors.length === 0 && warnings.length === 0) {
                logConsole('âœ” ValidaciÃ³n OK â€” sin errores', 'info');
                logConsole('Usa Submit â†‘ para cargar el cÃ³digo a la Radion', 'dim');
            } else {
                warnings.forEach(w => logConsole(`âš  LÃ­nea ${w.line}: ${w.msg}`, 'warn'));
                errors.forEach(e => logConsole(`âœ– LÃ­nea ${e.line}: ${e.msg}`, 'error'));
                logConsole(`â”€â”€â”€ ${errors.length} error(es), ${warnings.length} aviso(s) â€” corrige antes de Submit â”€â”€â”€`, 'dim');
            }
            targetCfg._lastValidation = { errors, warnings, code };
        }
    }

    function submitCfg() {
        if (!targetCfg || targetCfg.type !== 'RADION') return;
        const v = targetCfg._lastValidation;
        if (!v) {
            clearConsole();
            logConsole('âœ– Haz clic en Save primero para validar el cÃ³digo', 'error');
            return;
        }
        const currentCode = document.getElementById('m-code-area').value;
        if (currentCode !== v.code) {
            clearConsole();
            logConsole('âœ– El cÃ³digo cambiÃ³ desde la Ãºltima validaciÃ³n â€” vuelve a hacer Save', 'error');
            return;
        }
        if (v.errors.length > 0) {
            clearConsole();
            logConsole(`âœ– No se puede cargar: hay ${v.errors.length} error(es) sin corregir`, 'error');
            v.errors.forEach(e => logConsole(`  Â· LÃ­nea ${e.line}: ${e.msg}`, 'error'));
            logConsole('Corrige los errores y vuelve a hacer Save', 'dim');
            return;
        }
        targetCfg.code = v.code;
        targetCfg.memory = {d1:false, d2:false, d3:false};
        targetCfg.intState = {pc:0, wait:0, vars:{}, timers:{}, pinBlink:{}, parsed:null};
        targetCfg._lastValidation = null;
        clearConsole();
        logConsole('âœ” CÃ³digo cargado a la Radion 1.1', 'info');
        if (v.warnings.length > 0) {
            logConsole(`â„¹ ${v.warnings.length} aviso(s) ignorados al cargar`, 'warn');
        }
        setTimeout(() => closeCfg(), 700);
    }
    function repairCfg(){if(targetCfg)targetCfg.burned=false;closeCfg();}

    function spawn(type,xOpt,yOpt){
        const tx=(xOpt!==undefined)?xOpt:vMouse.x, ty=(yOpt!==undefined)?yOpt:vMouse.y;
        const comp={type,x:tx-50,y:ty-30,w:100,h:60,nodes:[],state:0,active:false,burned:false,rotation:0,selected:false};
        if(type==='BATTERY'){comp.nodes=[{id:'+',x:0,y:30},{id:'-',x:100,y:30}];comp.val=9;}
        else if(type==='LED')comp.nodes=[{id:'A',x:0,y:30},{id:'C',x:100,y:30}];
        else if(type==='MOTOR')comp.nodes=[{id:'M1',x:0,y:30},{id:'M2',x:100,y:30}];
        else if(type==='SWITCH'||type==='PUSH_BTN'){comp.closed=false;comp.nodes=[{id:'1',x:0,y:30},{id:'2',x:100,y:30}];}
        else if(type==='CAPACITOR'){comp.nodes=[{id:'+',x:0,y:30},{id:'-',x:100,y:30}];comp.charge=0;comp.val=10;}
        else if(type==='TRANSISTOR'){comp.nodes=[{id:'C',x:20,y:10},{id:'B',x:20,y:50},{id:'E',x:80,y:30}];comp.mode='NPN';}
        else if(type==='RESISTOR'){comp.nodes=[{id:'R1',x:0,y:30},{id:'R2',x:100,y:30}];comp.val=330;}
        else if(type==='RELAY'){comp.nodes=[{id:'C+',x:10,y:15},{id:'C-',x:10,y:45},{id:'COM',x:90,y:20},{id:'NO',x:90,y:40}];comp.coilState=false;}
        else if(type==='MUX'){comp.nodes=[{id:'A',x:0,y:15},{id:'B',x:0,y:45},{id:'S',x:50,y:50},{id:'OUT',x:100,y:30}];comp.selState=false;}
        else if(type==='AND'||type==='OR'||type==='XOR')comp.nodes=[{id:'I1',x:0,y:15},{id:'I2',x:0,y:45},{id:'OUT',x:100,y:30}];
        else if(type==='NOT')comp.nodes=[{id:'PWR',x:0,y:15},{id:'IN',x:0,y:45},{id:'OUT',x:100,y:30}];
        else if(type==='RSK90'){comp.nodes=[{id:'VCC',x:20,y:10},{id:'GND',x:20,y:50},{id:'OUT',x:80,y:30}];comp.lastTick=0;comp.clockState=false;}
        else if(type==='RADION'){
            comp.w=110;comp.h=130;
            comp.nodes=[
                {id:'VCC',x:15,y:15},{id:'GND',x:15,y:35},{id:'G',x:15,y:55},
                {id:'D1',x:95,y:15},{id:'D2',x:95,y:35},{id:'D3',x:95,y:55},
                {id:'D4',x:95,y:75},
                {id:'A1',x:15,y:75},
                {id:'SCL',x:95,y:95},{id:'SDA',x:95,y:115}
            ];
            comp.code=`start<\npin1=D1\nloop{\n  pin1;HIGH\n  delay 500\n  pin1;LOW\n  delay 500\n}\nend>`;
            comp.memory={d1:false,d2:false,d3:false,d4:false};
            comp.analog={a1:0};
            comp.intState={pc:0,wait:0,vars:{},timers:{},pinBlink:{},parsed:null};
        }
        else if(type==='OLED_I2C'){
            comp.w=120;comp.h=80;
            comp.nodes=[{id:'VCC',x:20,y:0},{id:'GND',x:45,y:0},{id:'SCL',x:70,y:0},{id:'SDA',x:95,y:0}];
            comp.textLines=[];comp.initialized=false;
        }
        else if(type==='WAYPOINT'){comp.x=tx-5;comp.y=ty-5;comp.w=10;comp.h=10;comp.nodes=[{id:'W',x:5,y:5}];}
        else if(type==='SERVO'){
            comp.w=90; comp.h=70;
            comp.nodes=[
                {id:'VCC',  x:15, y:0},
                {id:'GND',  x:45, y:0},
                {id:'SIG',  x:75, y:0},
            ];
            comp.angle = 90;
            comp.targetAngle = 90;
            comp.lastPulse = 0;
        }
        else if(type==='L298N'){
            comp.w=130; comp.h=100;
            comp.nodes=[
                {id:'VCC', x:0,  y:20},
                {id:'GND', x:0,  y:50},
                {id:'IN1', x:0,  y:75},
                {id:'IN2', x:30, y:100},
                {id:'OUT1',x:130,y:30},
                {id:'OUT2',x:130,y:70},
            ];
            comp.motorDir = 0;
        }
        components.push(comp); return comp;
    }

    function preprocessCode(code){
        const lines=code.split('\n');let blocks={};let stack=[];
        for(let i=0;i<lines.length;i++){
            let l=lines[i].trim();
            if(l.endsWith('{'))stack.push(i);
            else if(l==='}'){if(stack.length>0){let start=stack.pop();blocks[start]=i;blocks[i]=start;}}
        }
        return{lines,blocks};
    }

    function traceWire(startNode){
        let q=[startNode],visited=[],foundComps=[];
        while(q.length>0){
            let curr=q.shift();visited.push(curr);
            connections.forEach(conn=>{
                let next=null;
                if(conn.a.n===curr)next=conn.b.n; if(conn.b.n===curr)next=conn.a.n;
                if(next&&!visited.includes(next)){
                    visited.push(next);
                    let comp=components.find(c=>c.nodes.includes(next));
                    if(comp){if(comp.type==='WAYPOINT')q.push(next);else foundComps.push({comp,node:next});}
                }
            });
        }
        return foundComps;
    }

    function getI2C_OLED(radion){
        let sclN=radion.nodes.find(n=>n.id==='SCL'),sdaN=radion.nodes.find(n=>n.id==='SDA');
        let sclC=traceWire(sclN),sdaC=traceWire(sdaN);let oled=null;
        sclC.forEach(sc=>{if(sc.comp.type==='OLED_I2C'&&sc.node.id==='SCL'){sdaC.forEach(sd=>{if(sd.comp===sc.comp&&sd.node.id==='SDA')oled=sc.comp;});}});
        return oled;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RADION LOG v2.0 â€” IntÃ©rprete completo
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function runRadionLogic(c) {
        if (!c.active || c.burned) {
            c.memory.d1 = false; c.memory.d2 = false; c.memory.d3 = false; c.memory.d4 = false;
            c.intState = { pc:0, wait:0, vars:{}, timers:{}, parsed:null, pinBlink:{} };
            return;
        }
        if (!c.intState) c.intState = { pc:0, wait:0, vars:{}, timers:{}, parsed:null, pinBlink:{} };
        if (!c.intState.timers) c.intState.timers = {};
        if (!c.intState.pinBlink) c.intState.pinBlink = {};
        if (!c.intState.parsed) c.intState.parsed = preprocessCode(c.code);

        const now = Date.now();
        if (c.intState.wait > now) return;

        Object.keys(c.intState.pinBlink).forEach(pin => {
            const pb = c.intState.pinBlink[pin];
            if (!pb.active) return;
            if (now - pb.last >= pb.ms) {
                pb.state = !pb.state;
                pb.last = now;
                if (pin === 'D1') c.memory.d1 = pb.state;
                if (pin === 'D2') c.memory.d2 = pb.state;
                if (pin === 'D3') c.memory.d3 = pb.state;
            }
        });

        const { lines, blocks } = c.intState.parsed;
        let ix = 0;
        const max = 80;

        function readPin(pin) {
            if (pin === 'D1') return c.nodes[3].signal ? 1 : 0;
            if (pin === 'D2') return c.nodes[4].signal ? 1 : 0;
            if (pin === 'D3') return c.nodes[5].signal ? 1 : 0;
            if (pin === 'D4') return c.nodes[6].signal ? 1 : 0;
            if (pin === 'A1') return (c.analog && c.analog.a1 !== undefined) ? c.analog.a1 : (c.nodes[7].signal ? 1023 : 0);
            return 0;
        }

        function writePin(pin, state) {
            if (pin === 'D1') c.memory.d1 = state;
            if (pin === 'D2') c.memory.d2 = state;
            if (pin === 'D3') c.memory.d3 = state;
            if (pin === 'D4') c.memory.d4 = state;
        }

        function resolvePin(name) {
            const v = c.intState.vars[name];
            if (v === 'D1' || v === 'D2' || v === 'D3' || v === 'D4' || v === 'A1') return v;
            if (name === 'D1' || name === 'D2' || name === 'D3' || name === 'D4' || name === 'A1') return name;
            return null;
        }

        function callLibFunc(expr) {
            const m = expr.match(/^(math|str|timer|pin|oled)\.([\w]+)\((.*)?\)$/);
            if (!m) return undefined;
            const [, lib, fn, rawArgs] = m;
            const args = rawArgs ? rawArgs.split(',').map(a => evalExpr(a.trim())) : [];

            if (lib === 'math') {
                if (fn === 'abs')    return Math.abs(args[0]);
                if (fn === 'max')    return Math.max(args[0], args[1]);
                if (fn === 'min')    return Math.min(args[0], args[1]);
                if (fn === 'pow')    return Math.pow(args[0], args[1]);
                if (fn === 'sqrt')   return Math.sqrt(Math.max(0, args[0]));
                if (fn === 'floor')  return Math.floor(args[0]);
                if (fn === 'ceil')   return Math.ceil(args[0]);
                if (fn === 'round')  return Math.round(args[0]);
                if (fn === 'clamp')  return Math.min(Math.max(args[0], args[1]), args[2]);
                if (fn === 'map') {
                    const [v, i0, i1, o0, o1] = args;
                    return o0 + (v - i0) * (o1 - o0) / (i1 - i0);
                }
                if (fn === 'random') {
                    const lo = Math.ceil(args[0]), hi = Math.floor(args[1]);
                    return Math.floor(Math.random() * (hi - lo + 1)) + lo;
                }
                if (fn === 'sin')   return Math.sin(args[0]);
                if (fn === 'cos')   return Math.cos(args[0]);
                if (fn === 'pi')    return Math.PI;
            }

            if (lib === 'str') {
                const sa = args.map(a => String(a));
                if (fn === 'concat')  return sa.join('');
                if (fn === 'len')     return sa[0].length;
                if (fn === 'upper')   return sa[0].toUpperCase();
                if (fn === 'lower')   return sa[0].toLowerCase();
                if (fn === 'repeat')  return sa[0].repeat(Math.max(0, parseInt(args[1]) || 0));
                if (fn === 'substr')  return sa[0].substr(parseInt(args[1]) || 0, parseInt(args[2]) || sa[0].length);
                if (fn === 'indexOf') return sa[0].indexOf(sa[1]);
                if (fn === 'replace') return sa[0].replace(sa[1], sa[2]);
                if (fn === 'trim')    return sa[0].trim();
                if (fn === 'num')     return parseFloat(sa[0]) || 0;
            }

            if (lib === 'timer') {
                const id = rawArgs.split(',')[0].trim();
                if (fn === 'set') {
                    c.intState.timers[id] = { start: now, interval: parseFloat(args[1]) || 1000 };
                    return 0;
                }
                if (fn === 'check') {
                    const t = c.intState.timers[id];
                    if (!t) return 0;
                    return (now - t.start) >= t.interval ? 1 : 0;
                }
                if (fn === 'reset') {
                    if (c.intState.timers[id]) c.intState.timers[id].start = now;
                    return 0;
                }
                if (fn === 'elapsed') {
                    const t = c.intState.timers[id];
                    return t ? now - t.start : 0;
                }
                if (fn === 'remaining') {
                    const t = c.intState.timers[id];
                    return t ? Math.max(0, t.interval - (now - t.start)) : 0;
                }
            }

            if (lib === 'pin') {
                const pinName = rawArgs ? rawArgs.split(',')[0].trim() : '';
                const physPin = resolvePin(pinName) || pinName;
                if (fn === 'read')   return readPin(physPin);
                if (fn === 'write') {
                    const state = args[1] === 1 || String(args[1]).toUpperCase() === 'HIGH';
                    writePin(physPin, state);
                    return 0;
                }
                if (fn === 'toggle') {
                    if (physPin==='D1') c.memory.d1 = !c.memory.d1;
                    if (physPin==='D2') c.memory.d2 = !c.memory.d2;
                    if (physPin==='D3') c.memory.d3 = !c.memory.d3;
                    if (physPin==='D4') c.memory.d4 = !c.memory.d4;
                    return 0;
                }
                if (fn === 'off') { writePin(physPin, false); return 0; }
                if (fn === 'blink') {
                    c.intState.pinBlink[physPin] = { active:true, ms: parseFloat(args[1])||200, last: now, state: false };
                    return 0;
                }
                if (fn === 'stopBlink') {
                    if (c.intState.pinBlink[physPin]) c.intState.pinBlink[physPin].active = false;
                    return 0;
                }
            }

            if (lib === 'servo') {
                const pinName = rawArgs ? rawArgs.split(',')[0].trim() : 'D4';
                const physPin = resolvePin(pinName) || pinName;
                if (fn === 'write') {
                    const targetAngle = Math.min(180, Math.max(0, parseFloat(args[1]) || 0));
                    c.memory.d4 = true;
                    const pinNode = physPin === 'D4' ? c.nodes[6] : null;
                    if (pinNode) {
                        connections.forEach(conn => {
                            let other = null;
                            if (conn.a.n === pinNode) other = conn.b;
                            if (conn.b.n === pinNode) other = conn.a;
                            if (other && other.c.type === 'SERVO') {
                                other.c.targetAngle = targetAngle;
                                other.c.active = true;
                            }
                        });
                    }
                    return 0;
                }
                if (fn === 'read') {
                    const pinNode = physPin === 'D4' ? c.nodes[6] : null;
                    if (pinNode) {
                        let angle = 90;
                        connections.forEach(conn => {
                            let other = null;
                            if (conn.a.n === pinNode) other = conn.b;
                            if (conn.b.n === pinNode) other = conn.a;
                            if (other && other.c.type === 'SERVO') angle = other.c.angle;
                        });
                        return angle;
                    }
                    return 90;
                }
            }

            return undefined;
        }

        function evalExpr(expr) {
            if (!expr) return 0;
            expr = expr.trim();

            if (/^(math|str|timer|pin|servo)\.([\w]+)\(/.test(expr)) {
                const r = callLibFunc(expr);
                if (r !== undefined) return r;
            }

            if (expr.startsWith('(') && expr.endsWith(')')) {
                return evalExpr(expr.slice(1, -1));
            }

            for (let i = expr.length - 1; i >= 0; i--) {
                const ch = expr[i];
                if (ch === '+' || ch === '-') {
                    if (i === 0) continue;
                    const prev = expr[i-1];
                    if ('+-*/%(=<>!'.includes(prev)) continue;
                    const left = evalExpr(expr.slice(0, i));
                    const right = evalExpr(expr.slice(i + 1));
                    const nl = parseFloat(left), nr = parseFloat(right);
                    if (isNaN(nl) || isNaN(nr)) return String(left) + String(right);
                    return ch === '+' ? nl + nr : nl - nr;
                }
            }

            for (let i = expr.length - 1; i >= 0; i--) {
                const ch = expr[i];
                if (ch === '*' || ch === '/' || ch === '%') {
                    if (i === 0) continue;
                    const prev = expr[i-1];
                    if ('+-*/%(=<>!'.includes(prev)) continue;
                    const left = evalExpr(expr.slice(0, i));
                    const right = evalExpr(expr.slice(i + 1));
                    const nl = parseFloat(left), nr = parseFloat(right);
                    if (isNaN(nl) || isNaN(nr)) return 0;
                    if (ch === '*') return nl * nr;
                    if (ch === '/') return nr !== 0 ? nl / nr : 0;
                    if (ch === '%') return nr !== 0 ? nl % nr : 0;
                }
            }

            if (!isNaN(parseFloat(expr)) && isFinite(expr)) return parseFloat(expr);

            if (expr === 'HIGH') return 1;
            if (expr === 'LOW')  return 0;
            if (expr === 'true') return 1;
            if (expr === 'false') return 0;
            if (expr === 'PI')   return Math.PI;

            if (expr.startsWith('"') && expr.endsWith('"')) return expr.slice(1, -1);

            if (expr === 'D1') return readPin('D1');
            if (expr === 'D2') return readPin('D2');
            if (expr === 'D3') return readPin('D3');

            const v = c.intState.vars[expr];
            if (v !== undefined) {
                if (v === 'D1' || v === 'D2' || v === 'D3') return readPin(v);
                const vn = parseFloat(v);
                return !isNaN(vn) ? vn : v;
            }
            return expr;
        }

        function evalCond(condStr) {
            condStr = condStr.trim();
            if (condStr.startsWith('!')) return !evalCond(condStr.slice(1).trim());
            if (condStr.includes(' and ')) {
                const parts = condStr.split(' and ');
                return parts.every(p => evalCond(p.trim()));
            }
            if (condStr.includes(' or ')) {
                const parts = condStr.split(' or ');
                return parts.some(p => evalCond(p.trim()));
            }
            const operators = ['>=', '<=', '!=', '==', '>', '<'];
            for (const op of operators) {
                const idx = condStr.indexOf(op);
                if (idx === -1) continue;
                const lv = evalExpr(condStr.slice(0, idx).trim());
                const rv = evalExpr(condStr.slice(idx + op.length).trim());
                const ln = parseFloat(lv), rn = parseFloat(rv);
                if (!isNaN(ln) && !isNaN(rn)) {
                    if (op === '==') return ln === rn;
                    if (op === '!=') return ln !== rn;
                    if (op === '>')  return ln > rn;
                    if (op === '<')  return ln < rn;
                    if (op === '>=') return ln >= rn;
                    if (op === '<=') return ln <= rn;
                }
                const ls = String(lv), rs = String(rv);
                if (op === '==') return ls === rs;
                if (op === '!=') return ls !== rs;
                return false;
            }
            const v = evalExpr(condStr);
            return v !== 0 && v !== 'LOW' && v !== '' && v !== false;
        }

        function resolveDisplay(token) {
            if (token.startsWith('"') && token.endsWith('"')) return token.slice(1, -1);
            const val = evalExpr(token);
            if (typeof val === 'number') {
                return Number.isInteger(val) ? String(val) : parseFloat(val.toFixed(3)).toString();
            }
            return String(val);
        }

        function makeBar(val, lo, hi, width) {
            width = width || 8;
            const pct = Math.max(0, Math.min(1, (val - lo) / (hi - lo)));
            const filled = Math.round(pct * width);
            return '[' + 'â–ˆ'.repeat(filled) + 'â–‘'.repeat(width - filled) + ']';
        }

        try {
        while (ix < max) {
            if (c.intState.pc >= lines.length) break;
            let line = lines[c.intState.pc].trim();

            if (!line || line.startsWith('//') || line === 'start<' || line === 'end>') {
                c.intState.pc++; ix++; continue;
            }

            if (line === 'else {' || line === 'else{') {
                c.intState.pc = (blocks[c.intState.pc] !== undefined)
                    ? blocks[c.intState.pc] + 1
                    : c.intState.pc + 1;
                ix++; continue;
            }

            if (line.startsWith('if ')) {
                const condMatch = line.match(/^if\s+(.+?)\s*\{$/);
                let cond = false;
                if (condMatch) cond = evalCond(condMatch[1].trim());
                if (cond) {
                    c.intState.pc++;
                } else {
                    const closeIdx = blocks[c.intState.pc];
                    if (closeIdx !== undefined) {
                        const nextLine = lines[closeIdx + 1] ? lines[closeIdx + 1].trim() : '';
                        if (nextLine === 'else {' || nextLine === 'else{') {
                            c.intState.pc = closeIdx + 2;
                        } else {
                            c.intState.pc = closeIdx + 1;
                        }
                    } else {
                        c.intState.pc++;
                    }
                }
                ix++; continue;
            }

            if (line.startsWith('while ')) {
                const condMatch = line.match(/^while\s+(.+?)\s*\{$/);
                let cond = false;
                if (condMatch) cond = evalCond(condMatch[1].trim());
                if (cond) {
                    c.intState.pc++;
                } else {
                    c.intState.pc = (blocks[c.intState.pc] !== undefined)
                        ? blocks[c.intState.pc] + 1
                        : c.intState.pc + 1;
                }
                ix++; continue;
            }

            if (line.startsWith('for ')) {
                const forMatch = line.match(/^for\s+(\w+)=(.+?)\s+to\s+(.+?)\s*\{$/);
                if (forMatch) {
                    const varName = forMatch[1];
                    const ini = evalExpr(forMatch[2].trim());
                    const fin = evalExpr(forMatch[3].trim());
                    const cur = c.intState.vars[varName] !== undefined ? parseFloat(c.intState.vars[varName]) : ini;
                    const step = ini <= fin ? 1 : -1;
                    const finished = step > 0 ? cur > fin : cur < fin;
                    if (!finished) {
                        if (c.intState.vars[varName] === undefined) c.intState.vars[varName] = ini;
                        c.intState.pc++;
                    } else {
                        delete c.intState.vars[varName];
                        c.intState.pc = (blocks[c.intState.pc] !== undefined)
                            ? blocks[c.intState.pc] + 1
                            : c.intState.pc + 1;
                    }
                } else { c.intState.pc++; }
                ix++; continue;
            }

            if (line.endsWith('{')) { c.intState.pc++; ix++; continue; }

            if (line === '}') {
                const sl = blocks[c.intState.pc];
                if (sl !== undefined) {
                    const headerLine = lines[sl].trim();
                    if (headerLine.startsWith('loop') || headerLine.startsWith('while')) {
                        c.intState.pc = sl; ix++; continue;
                    } else if (headerLine.startsWith('for ')) {
                        const forMatch = headerLine.match(/^for\s+(\w+)=(.+?)\s+to\s+(.+?)\s*\{$/);
                        if (forMatch) {
                            const varName = forMatch[1];
                            const fin = evalExpr(forMatch[3].trim());
                            const ini = evalExpr(forMatch[2].trim());
                            const step = ini <= fin ? 1 : -1;
                            c.intState.vars[varName] = (parseFloat(c.intState.vars[varName]) || 0) + step;
                        }
                        c.intState.pc = sl; ix++; continue;
                    } else {
                        c.intState.pc++;
                    }
                } else { c.intState.pc++; }
                ix++; continue;
            }

            if (line.startsWith('delay ')) {
                const ms = parseFloat(evalExpr(line.slice(6).trim())) || 100;
                c.intState.wait = now + ms;
                c.intState.pc++;
                return;
            }

            if (line.startsWith('toggle ')) {
                const varName = line.slice(7).trim();
                const pin = resolvePin(varName);
                if (pin === 'D1') c.memory.d1 = !c.memory.d1;
                else if (pin === 'D2') c.memory.d2 = !c.memory.d2;
                else if (pin === 'D3') c.memory.d3 = !c.memory.d3;
                c.intState.pc++; ix++; continue;
            }

            if (line.startsWith('print ') && !line.startsWith('println')) {
                const oled = getI2C_OLED(c);
                if (oled && oled.active && oled.initialized) {
                    const text = resolveDisplay(line.slice(6).trim());
                    if (!oled.textLines.length) oled.textLines.push('');
                    oled.textLines[oled.textLines.length - 1] += text;
                }
                c.intState.pc++; ix++; continue;
            }
            if (line.startsWith('println ')) {
                const oled = getI2C_OLED(c);
                if (oled && oled.active && oled.initialized) {
                    const text = resolveDisplay(line.slice(8).trim());
                    if (!oled.textLines.length) oled.textLines.push('');
                    oled.textLines[oled.textLines.length - 1] += text;
                    if (oled.textLines.length >= 4) oled.textLines.shift();
                    oled.textLines.push('');
                }
                c.intState.pc++; ix++; continue;
            }

            if (line.startsWith('oled.')) {
                const oled = getI2C_OLED(c);
                if (oled && oled.active && !oled.burned) {
                    if (line === 'oled.init') {
                        oled.textLines = ['']; oled.initialized = true; oled.cursor = {row:0, col:0};

                    } else if (line === 'oled.clear') {
                        if (oled.initialized) { oled.textLines = ['']; oled.cursor = {row:0,col:0}; }

                    } else if (line.startsWith('oled.print ') || line.startsWith('oled.println ')) {
                        const isPrintln = line.startsWith('oled.println ');
                        const raw = line.slice(isPrintln ? 13 : 11).trim();
                        const text = resolveDisplay(raw);
                        if (oled.initialized) {
                            if (!oled.textLines.length) oled.textLines.push('');
                            oled.textLines[oled.textLines.length - 1] += text;
                            if (isPrintln) {
                                if (oled.textLines.length >= 4) oled.textLines.shift();
                                oled.textLines.push('');
                            }
                        }

                    } else if (line.startsWith('oled.draw.bar(')) {
                        const m = line.match(/oled\.draw\.bar\((.+),(.+),(.+)\)/);
                        if (m && oled.initialized) {
                            const bar = makeBar(evalExpr(m[1].trim()), evalExpr(m[2].trim()), evalExpr(m[3].trim()));
                            if (!oled.textLines.length) oled.textLines.push('');
                            oled.textLines[oled.textLines.length - 1] += bar;
                        }

                    } else if (line.startsWith('oled.setCursor(')) {
                        const m = line.match(/oled\.setCursor\((.+),(.+)\)/);
                        if (m && oled.initialized) {
                            const col = parseInt(evalExpr(m[1].trim())) || 0;
                            const row = parseInt(evalExpr(m[2].trim())) || 0;
                            while (oled.textLines.length <= row) oled.textLines.push('');
                            oled.cursor = { row, col };
                        }

                    } else if (line.startsWith('oled.printAt(')) {
                        const m = line.match(/oled\.printAt\((.+),(.+),(.+)\)/);
                        if (m && oled.initialized) {
                            const col = parseInt(evalExpr(m[1].trim())) || 0;
                            const row = parseInt(evalExpr(m[2].trim())) || 0;
                            const text = resolveDisplay(m[3].trim());
                            while (oled.textLines.length <= row) oled.textLines.push('');
                            const line_ = oled.textLines[row].padEnd(col, ' ');
                            oled.textLines[row] = line_.slice(0, col) + text + line_.slice(col + text.length);
                        }

                    } else if (line === 'oled.scroll.up') {
                        if (oled.initialized && oled.textLines.length > 1) oled.textLines.shift();

                    } else if (line === 'oled.invert') {
                        oled.inverted = !oled.inverted;
                    }
                }
                c.intState.pc++; ix++; continue;
            }

            if (line.startsWith('console.')) {
                const isConsoleOnly = c === consoleOwner;
                if (line.startsWith('console.print ') || line.startsWith('console.println ')) {
                    const isPln = line.startsWith('console.println ');
                    const raw = line.slice(isPln ? 16 : 14).trim();
                    const text = resolveDisplay(raw);
                    if (isConsoleOnly) logConsole(text, 'print');
                } else if (line.startsWith('console.warn ')) {
                    const text = resolveDisplay(line.slice(13).trim());
                    if (isConsoleOnly) logConsole('âš  ' + text, 'warn');
                } else if (line.startsWith('console.error ')) {
                    const text = resolveDisplay(line.slice(14).trim());
                    if (isConsoleOnly) logConsole('âœ– ' + text, 'error');
                } else if (line.startsWith('console.info ')) {
                    const text = resolveDisplay(line.slice(13).trim());
                    if (isConsoleOnly) logConsole('â„¹ ' + text, 'info');
                } else if (line === 'console.clear') {
                    if (isConsoleOnly) clearConsole();
                }
                c.intState.pc++; ix++; continue;
            }

            if (/^(math|str|timer|pin|servo)\.([\w]+)\(/.test(line)) {
                callLibFunc(line);
                c.intState.pc++; ix++; continue;
            }

            if (line.includes(';')) {
                const parts = line.split(';');
                const varName = parts[0].trim();
                const rest = parts[1].trim();
                const inlineIf = rest.match(/^(HIGH|LOW)\s+if\s+(.+)$/);
                let state;
                if (inlineIf) {
                    const cond = evalCond(inlineIf[2].trim());
                    if (!cond) { c.intState.pc++; ix++; continue; }
                    state = inlineIf[1] === 'HIGH';
                } else {
                    state = rest === 'HIGH';
                }
                const pin = resolvePin(varName);
                if (pin) writePin(pin, state);
                c.intState.pc++; ix++; continue;
            }

            if (line.includes('=') && !line.startsWith('if ') && !line.startsWith('while ') && !line.startsWith('for ')) {
                const eqIdx = line.indexOf('=');
                const varName = line.slice(0, eqIdx).trim();
                const exprStr = line.slice(eqIdx + 1).trim();
                if (exprStr === 'D1' || exprStr === 'D2' || exprStr === 'D3') {
                    c.intState.vars[varName] = exprStr;
                } else {
                    c.intState.vars[varName] = evalExpr(exprStr);
                }
                c.intState.pc++; ix++; continue;
            }

            c.intState.pc++; ix++;
        }
        } catch(err) {
            const lineNum = c.intState.pc + 1;
            if (c === consoleOwner) {
                logConsole(`âœ– Runtime error en lÃ­nea ${lineNum}: ${err.message}`, 'error');
            }
            c.intState.pc++;
        }
    }

    function updatePhysics(){
        components.forEach(c=>{c.state=0;if(c.type!=='CAPACITOR')c.active=false;if(c.type==='RELAY')c.coilActiveThisFrame=false;});
        connections.forEach(conn=>{conn.active=false;conn.flowDir=1;});
        components.filter(c=>c.type==='CAPACITOR').forEach(cap=>{if(cap.charge>0)cap.isSource=true;else{cap.isSource=false;cap.active=false;}});
        components.forEach(c=>c.nodes.forEach(n=>n.signal=false));
        const sources=components.filter(c=>(c.type==='BATTERY'||(c.type==='CAPACITOR'&&c.isSource)||(c.type==='RSK90'&&c.clockState)||(c.type==='RADION'&&(c.memory.d1||c.memory.d2||c.memory.d3||c.memory.d4)))&&!c.burned);
        sources.forEach(src=>{
            let startNodes=[];
            if(src.type==='BATTERY'||src.type==='CAPACITOR')startNodes.push(src.nodes[0]);
            else if(src.type==='RSK90')startNodes.push(src.nodes[2]);
            else if(src.type==='RADION'){if(src.memory.d1)startNodes.push(src.nodes[3]);if(src.memory.d2)startNodes.push(src.nodes[4]);if(src.memory.d3)startNodes.push(src.nodes[5]);if(src.memory.d4)startNodes.push(src.nodes[6]);}
            startNodes.forEach(sn=>{
                let q=[sn];sn.signal=true;
                while(q.length>0){
                    let curr=q.shift();
                    connections.forEach(conn=>{let next=null;if(conn.a.n===curr)next=conn.b.n;if(conn.b.n===curr)next=conn.a.n;if(next&&!next.signal){next.signal=true;q.push(next);}});
                    const comp=components.find(c=>c.nodes.includes(curr));
                    if(comp&&!comp.burned){
                        if((comp.type==='SWITCH'||comp.type==='PUSH_BTN')&&!comp.closed)continue;
                        if(comp.type==='RELAY'){if((curr===comp.nodes[2]||curr===comp.nodes[3])&&!comp.coilState)continue;}
                        if(comp.type==='MUX'){const sel=comp.selState;if(curr===comp.nodes[0]){if(!sel&&!comp.nodes[3].signal){comp.nodes[3].signal=true;q.push(comp.nodes[3]);}}else if(curr===comp.nodes[1]){if(sel&&!comp.nodes[3].signal){comp.nodes[3].signal=true;q.push(comp.nodes[3]);}}else if(curr===comp.nodes[3]){let dest=sel?comp.nodes[1]:comp.nodes[0];if(!dest.signal){dest.signal=true;q.push(dest);}}continue;}
                        if(comp.type==='LED'&&curr!==comp.nodes[0])continue;
                        if(comp.type==='CAPACITOR'&&curr!==comp.nodes[0])continue;
                        if(comp.type==='TRANSISTOR')continue;
                        if(['AND','OR','NOT','XOR','RSK90','RADION','OLED_I2C'].includes(comp.type))continue;
                        if(comp.type==='L298N')continue;
                        if(comp.type==='SERVO')continue;
                        comp.nodes.forEach(n=>{if(!n.signal){n.signal=true;q.push(n);}});
                    }
                }
            });
        });
        components.filter(c=>(c.type==='BATTERY'||(c.type==='CAPACITOR'&&c.isSource))&&!c.burned).forEach(bat=>{
            let foundPaths=[];
            function dfs(currentNode,currentPath,visitedNodes){
                if(currentNode===bat.nodes[1]){foundPaths.push([...currentPath]);return;}
                connections.forEach(conn=>{
                    if(conn.a.n===currentNode&&!visitedNodes.includes(conn.b.n))dfs(conn.b.n,[...currentPath,{t:'wire',c:conn,dir:1}],[...visitedNodes,conn.b.n]);
                    if(conn.b.n===currentNode&&!visitedNodes.includes(conn.a.n))dfs(conn.a.n,[...currentPath,{t:'wire',c:conn,dir:-1}],[...visitedNodes,conn.a.n]);
                });
                const comp=components.find(c=>c.nodes.includes(currentNode));
                if(comp&&comp!==bat&&!comp.burned){
                    let outNodes=[];let direction=(currentNode===comp.nodes[0])?1:-1;
                    if(comp.type==='TRANSISTOR'){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[2]);else if(currentNode===comp.nodes[2])outNodes.push(comp.nodes[0]);}
                    else if(['AND','OR','NOT','XOR'].includes(comp.type)){if(currentNode===comp.nodes[0]||currentNode===comp.nodes[1])outNodes.push(comp.nodes[2]);}
                    else if(comp.type==='RELAY'){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[1]);if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[0]);if(currentNode===comp.nodes[2])outNodes.push(comp.nodes[3]);if(currentNode===comp.nodes[3])outNodes.push(comp.nodes[2]);}
                    else if(comp.type==='MUX'){const sel=comp.selState;if(currentNode===comp.nodes[0]&&!sel)outNodes.push(comp.nodes[3]);if(currentNode===comp.nodes[1]&&sel)outNodes.push(comp.nodes[3]);if(currentNode===comp.nodes[3]){if(sel)outNodes.push(comp.nodes[1]);else outNodes.push(comp.nodes[0]);}}
                    else if(comp.type==='RSK90'){if(currentNode===comp.nodes[0]){outNodes.push(comp.nodes[1]);outNodes.push(comp.nodes[2]);}if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[0]);if(currentNode===comp.nodes[2])outNodes.push(comp.nodes[0]);}
                    else if(comp.type==='RADION'){
                        if(currentNode===comp.nodes[0]){outNodes.push(comp.nodes[1]);outNodes.push(comp.nodes[2]);}
                        if(currentNode===comp.nodes[1]){outNodes.push(comp.nodes[2]);outNodes.push(comp.nodes[0]);}
                        if(currentNode===comp.nodes[2]){outNodes.push(comp.nodes[1]);outNodes.push(comp.nodes[0]);}
                        if(comp.memory.d1){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[3]);if(currentNode===comp.nodes[3])outNodes.push(comp.nodes[0]);}
                        if(comp.memory.d2){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[4]);if(currentNode===comp.nodes[4])outNodes.push(comp.nodes[0]);}
                        if(comp.memory.d3){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[5]);if(currentNode===comp.nodes[5])outNodes.push(comp.nodes[0]);}
                        if(comp.memory.d4){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[6]);if(currentNode===comp.nodes[6])outNodes.push(comp.nodes[0]);}
                    }
                    else if(comp.type==='OLED_I2C'){if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[1]);}
                    else if(comp.type==='L298N'){
                        if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[1]);
                        if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[0]);
                        const in1=comp.nodes[2].signal, in2=comp.nodes[3].signal;
                        if(in1&&!in2){
                            if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[4]);
                            if(currentNode===comp.nodes[4])outNodes.push(comp.nodes[0]);
                            if(currentNode===comp.nodes[5])outNodes.push(comp.nodes[1]);
                            if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[5]);
                        }
                        if(!in1&&in2){
                            if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[5]);
                            if(currentNode===comp.nodes[5])outNodes.push(comp.nodes[0]);
                            if(currentNode===comp.nodes[4])outNodes.push(comp.nodes[1]);
                            if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[4]);
                        }
                    }
                    else if(comp.type==='BATTERY'&&comp!==bat){
                        if(currentNode===comp.nodes[1])outNodes.push(comp.nodes[0]);
                        if(currentNode===comp.nodes[0])outNodes.push(comp.nodes[1]);
                    }
                    else{outNodes.push(comp.nodes.find(n=>n!==currentNode));}
                    outNodes.forEach(otherNode=>{
                        if(otherNode&&!visitedNodes.includes(otherNode)){
                            let canCross=false;
                            if(comp.type==='RESISTOR'||comp.type==='MOTOR'||comp.type==='WAYPOINT')canCross=true;
                            if(comp.type==='BATTERY'&&comp!==bat)canCross=true;
                            if((comp.type==='SWITCH'||comp.type==='PUSH_BTN')&&comp.closed)canCross=true;
                            if(comp.type==='RELAY'){if((currentNode===comp.nodes[0]&&otherNode===comp.nodes[1])||(currentNode===comp.nodes[1]&&otherNode===comp.nodes[0]))canCross=true;if((currentNode===comp.nodes[2]&&otherNode===comp.nodes[3])||(currentNode===comp.nodes[3]&&otherNode===comp.nodes[2])){if(comp.coilState)canCross=true;}}
                            if(comp.type==='MUX')canCross=true;
                            if(comp.type==='LED'&&direction===1)canCross=true;
                            if(comp.type==='CAPACITOR'&&bat.type==='BATTERY')canCross=true;
                            if(comp.type==='AND'&&comp.nodes[0].signal&&comp.nodes[1].signal)canCross=true;
                            if(comp.type==='OR'&&(comp.nodes[0].signal||comp.nodes[1].signal))canCross=true;
                            if(comp.type==='XOR'&&((comp.nodes[0].signal&&!comp.nodes[1].signal)||(!comp.nodes[0].signal&&comp.nodes[1].signal)))canCross=true;
                            if(comp.type==='NOT'&&currentNode===comp.nodes[0]&&!comp.nodes[1].signal)canCross=true;
                            if(comp.type==='RSK90'){if((currentNode===comp.nodes[0]&&otherNode===comp.nodes[1])||(currentNode===comp.nodes[1]&&otherNode===comp.nodes[0]))canCross=true;if(comp.clockState&&((currentNode===comp.nodes[0]&&otherNode===comp.nodes[2])||(currentNode===comp.nodes[2]&&otherNode===comp.nodes[0])))canCross=true;}
                            if(comp.type==='RADION'){const isPwr=(n)=>n===comp.nodes[0]||n===comp.nodes[1]||n===comp.nodes[2];if(isPwr(currentNode)&&isPwr(otherNode))canCross=true;if(comp.memory.d1&&((currentNode===comp.nodes[0]&&otherNode===comp.nodes[3])||(currentNode===comp.nodes[3]&&otherNode===comp.nodes[0])))canCross=true;if(comp.memory.d2&&((currentNode===comp.nodes[0]&&otherNode===comp.nodes[4])||(currentNode===comp.nodes[4]&&otherNode===comp.nodes[0])))canCross=true;if(comp.memory.d3&&((currentNode===comp.nodes[0]&&otherNode===comp.nodes[5])||(currentNode===comp.nodes[5]&&otherNode===comp.nodes[0])))canCross=true;if(comp.memory.d4&&((currentNode===comp.nodes[0]&&otherNode===comp.nodes[6])||(currentNode===comp.nodes[6]&&otherNode===comp.nodes[0])))canCross=true;}
                            if(comp.type==='SERVO'){const isPwr=(n)=>n===comp.nodes[0]||n===comp.nodes[1];if(isPwr(currentNode)&&isPwr(otherNode))canCross=true;}
                            if(comp.type==='OLED_I2C'){const isPwr=(n)=>n===comp.nodes[0]||n===comp.nodes[1];if(isPwr(currentNode)&&isPwr(otherNode))canCross=true;}
                            if(comp.type==='L298N'){
                                const in1=comp.nodes[2].signal, in2=comp.nodes[3].signal;
                                const vcc=comp.nodes[0], gnd=comp.nodes[1], o1=comp.nodes[4], o2=comp.nodes[5];
                                if((currentNode===vcc&&otherNode===gnd)||(currentNode===gnd&&otherNode===vcc))canCross=true;
                                if(in1&&!in2){
                                    if((currentNode===vcc&&otherNode===o1)||(currentNode===o1&&otherNode===vcc))canCross=true;
                                    if((currentNode===o2&&otherNode===gnd)||(currentNode===gnd&&otherNode===o2))canCross=true;
                                }
                                if(!in1&&in2){
                                    if((currentNode===vcc&&otherNode===o2)||(currentNode===o2&&otherNode===vcc))canCross=true;
                                    if((currentNode===o1&&otherNode===gnd)||(currentNode===gnd&&otherNode===o1))canCross=true;
                                }
                            }
                            if(comp.type==='TRANSISTOR'){const bs=comp.nodes[1].signal;if(comp.mode==='NPN'){if(bs)canCross=true;}else{if(!bs)canCross=true;}}
                            if(canCross)dfs(otherNode,[...currentPath,{t:'comp',comp,dir:direction}],[...visitedNodes,otherNode]);
                        }
                    });
                }
            }
            dfs(bat.nodes[0],[],[bat.nodes[0]]);
            if(foundPaths.length>0){
                if(bat.type==='CAPACITOR')bat.charge-=2.0;
                foundPaths.forEach(path=>{
                    let rSum=0.1,ledCount=0,pathComps=[],extraVoltage=0;
                    path.forEach(step=>{
                        if(step.t==='comp'){
                            pathComps.push(step.comp);
                            if(step.comp.type==='BATTERY'&&step.comp!==bat)extraVoltage+=step.comp.val;
                            if(step.comp.type==='RESISTOR')rSum+=step.comp.val;
                            if(step.comp.type==='RELAY')rSum+=50;
                            if(step.comp.type==='RSK90')rSum+=1000;
                            if(step.comp.type==='RADION')rSum+=1200;
                            if(step.comp.type==='OLED_I2C')rSum+=1000;
                            if(step.comp.type==='L298N')rSum+=800;
                            if(step.comp.type==='SERVO')rSum+=600;
                            if(step.comp.type==='LED')ledCount++;
                            if(['AND','OR','NOT','XOR','MUX'].includes(step.comp.type))rSum+=10;
                            if(step.comp.type==='CAPACITOR'&&bat.type==='BATTERY'){let cr=50/(step.comp.val||10);step.comp.charge=Math.min(100,step.comp.charge+cr);step.comp.active=true;}
                        }
                    });
                    let vNet=(bat.val+extraVoltage)-(ledCount*2),current=vNet>0?(vNet/rSum):0,popped=false;
                    if(current>0){
                        if(bat.type==='BATTERY'&&current>5.0){bat.burned=true;popped=true;}
                        pathComps.forEach(c=>{
                            if(c.type==='LED'&&current>0.035){c.burned=true;popped=true;}
                            if(c.type==='RESISTOR'&&(current*current*c.val)>0.5){c.burned=true;popped=true;}
                            if(['AND','OR','NOT','XOR','MUX'].includes(c.type)&&current>0.2){c.burned=true;popped=true;}
                            if(c.type==='TRANSISTOR'&&current>1.0){c.burned=true;popped=true;}
                            if(c.type==='OLED_I2C'&&current>0.5){c.burned=true;popped=true;}
                        });
                    }
                    if(!popped&&current>0){
                        bat.active=true;
                        path.forEach(step=>{
                            if(step.t==='wire'){step.c.active=true;step.c.flowDir=step.dir;}
                            if(step.t==='comp'){step.comp.active=true;if(step.comp.type==='LED')step.comp.state=1;if(step.comp.type==='MOTOR')step.comp.state=step.dir;if(step.comp.type==='RELAY')step.comp.coilActiveThisFrame=true;}
                        });
                    }
                });
            }
        });
        components.filter(c=>c.type==='RELAY').forEach(r=>r.coilState=r.coilActiveThisFrame);
        components.filter(c=>c.type==='MUX').forEach(m=>{m.selState=m.nodes[2].signal;});
        components.filter(c=>c.type==='L298N').forEach(d=>{
            const in1=d.nodes[2].signal, in2=d.nodes[3].signal;
            if(in1&&!in2) d.motorDir=1;
            else if(!in1&&in2) d.motorDir=-1;
            else d.motorDir=0;
        });
        components.filter(c=>c.type==='SERVO').forEach(s=>{
            if(!s.active||s.burned){s.angle=90;s.targetAngle=90;return;}
            const diff=s.targetAngle-s.angle;
            if(Math.abs(diff)>0.5) s.angle+=diff*0.12;
            else s.angle=s.targetAngle;
        });
        components.filter(c=>c.type==='RSK90').forEach(c=>{
            if(c.active&&!c.burned){const now=Date.now();if(!c.lastTick)c.lastTick=now;if(now-c.lastTick>=1000){c.clockState=!c.clockState;c.lastTick=now;}}
            else{c.clockState=false;c.lastTick=0;}
        });
        components.filter(c=>c.type==='RADION').forEach(c=>runRadionLogic(c));
    }

    // â”€â”€â”€ DRAW â”€â”€â”€
    function drawGrid(camX,camY,zoom){
        const size=50;
        const halfW=(canvas.width/2)/zoom,halfH=(canvas.height/2)/zoom;
        const sx=Math.floor((camX-halfW)/size)*size-size,ex=camX+halfW+size;
        const sy=Math.floor((camY-halfH)/size)*size-size,ey=camY+halfH+size;

        ctx.strokeStyle='rgba(255,255,255,0.06)';
        ctx.lineWidth=1/zoom;
        ctx.beginPath();
        for(let x=sx;x<ex;x+=size){ ctx.moveTo(x,sy); ctx.lineTo(x,ey); }
        for(let y=sy;y<ey;y+=size){ ctx.moveTo(sx,y); ctx.lineTo(ex,y); }
        ctx.stroke();

        ctx.strokeStyle='rgba(0,212,255,0.07)';
        ctx.lineWidth=1/zoom;
        ctx.beginPath();
        for(let x=sx;x<ex;x+=size*5){ ctx.moveTo(x,sy); ctx.lineTo(x,ey); }
        for(let y=sy;y<ey;y+=size*5){ ctx.moveTo(sx,y); ctx.lineTo(ex,y); }
        ctx.stroke();

        ctx.fillStyle='rgba(255,255,255,0.18)';
        for(let x=sx;x<ex;x+=size)for(let y=sy;y<ey;y+=size)ctx.fillRect(x-0.8/zoom,y-0.8/zoom,1.6/zoom,1.6/zoom);
    }

    const C_BODY  = 'rgba(18,26,46,0.85)';
    const C_BORD  = 'rgba(255,255,255,0.13)';
    const C_BORD_ACTIVE = 'rgba(0,212,255,0.5)';
    const C_BORD_BURN   = 'rgba(255,71,87,0.6)';
    const C_TEXT  = '#8892a4';
    const C_TEXT2 = '#3d4559';
    const C_CYAN  = '#00d4ff';
    const C_GREEN = '#00e676';
    const C_AMBER = '#ffb700';
    const C_RED   = '#ff4757';

    function baseRect(c,dW,dH,override){
        ctx.fillStyle = override || C_BODY;
        ctx.strokeStyle = c.burned ? C_BORD_BURN : (c.active ? C_BORD_ACTIVE : C_BORD);
        ctx.lineWidth = 1;
        ctx.fillRect(c.x,c.y,dW,dH);
        ctx.strokeRect(c.x,c.y,dW,dH);
    }

    function label(text,x,y,color,size){
        ctx.fillStyle=color||C_TEXT2;
        ctx.font=`${size||8}px 'DM Mono', monospace`;
        ctx.fillText(text,x,y);
    }

    function draw(){
        if(draggingComp && isDesktopMode){
            if(draggingComp.group){const dx=vMouse.x-draggingComp.ox,dy=vMouse.y-draggingComp.oy;selectedItems.forEach(c=>{c.x+=dx;c.y+=dy;});draggingComp.ox=vMouse.x;draggingComp.oy=vMouse.y;}
            else{draggingComp.c.x=vMouse.x-draggingComp.ox;draggingComp.c.y=vMouse.y-draggingComp.oy;}
        }
        vMouse.lastDown=vMouse.isDown;
        updatePhysics(); rotAnim+=0.2; time+=0.5;

        document.getElementById('cx').textContent=Math.round(vMouse.x);
        document.getElementById('cy').textContent=Math.round(vMouse.y);
        document.getElementById('cz').textContent=camera.zoom.toFixed(1);

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();
        ctx.translate(canvas.width/2,canvas.height/2);
        ctx.scale(camera.zoom,camera.zoom);
        ctx.translate(-camera.x,-camera.y);

        drawGrid(camera.x,camera.y,camera.zoom);

        connections.forEach(conn=>{
            const ax=conn.a.c.x+conn.a.n.x,ay=conn.a.c.y+conn.a.n.y;
            const bx=conn.b.c.x+conn.b.n.x,by=conn.b.c.y+conn.b.n.y;
            if(conn.active){
                ctx.strokeStyle='rgba(0,212,255,0.08)'; ctx.lineWidth=7; ctx.setLineDash([]);
                ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
                ctx.strokeStyle='rgba(0,212,255,0.7)'; ctx.lineWidth=1.5;
                ctx.setLineDash([5,5]); ctx.lineDashOffset=-time*conn.flowDir;
                ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
                ctx.setLineDash([]);
            }else{
                ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=1.5; ctx.setLineDash([]);
                ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
            }
        });

        if(drawingCable){
            ctx.strokeStyle='rgba(0,212,255,0.4)'; ctx.lineWidth=1.5; ctx.setLineDash([4,4]);
            ctx.beginPath(); ctx.moveTo(drawingCable.c.x+drawingCable.n.x,drawingCable.c.y+drawingCable.n.y); ctx.lineTo(vMouse.x,vMouse.y); ctx.stroke(); ctx.setLineDash([]);
        }

        components.forEach(c=>{
            if(c.type==='WAYPOINT'){
                ctx.fillStyle='rgba(255,255,255,0.15)'; ctx.beginPath(); ctx.arc(c.x+5,c.y+5,3,0,Math.PI*2); ctx.fill(); return;
            }
            ctx.save();
            ctx.translate(c.x+c.w/2,c.y+c.h/2); ctx.rotate(c.rotation*Math.PI/2); ctx.translate(-(c.x+c.w/2),-(c.y+c.h/2));

            if(c.selected||selectedItems.includes(c)){
                let dW=(c.rotation%2===0)?c.w:c.h,dH=(c.rotation%2===0)?c.h:c.w;
                ctx.strokeStyle='rgba(0,212,255,0.5)'; ctx.lineWidth=1; ctx.setLineDash([4,4]);
                ctx.strokeRect(c.x-5,c.y-5,dW+10,dH+10); ctx.setLineDash([]);
            }

            let dW=(c.rotation%2===0)?c.w:c.h, dH=(c.rotation%2===0)?c.h:c.w;

            if(c.type==='LED'){
                baseRect(c,dW,dH);
                if(c.state&&!c.burned){
                    ctx.fillStyle='rgba(255,220,80,0.06)'; ctx.fillRect(c.x,c.y,dW,dH);
                    ctx.shadowBlur=14; ctx.shadowColor='rgba(255,220,80,0.5)';
                }
                ctx.strokeStyle=c.state&&!c.burned?'rgba(255,220,80,0.9)':(c.burned?C_RED:'rgba(255,255,255,0.2)');
                ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.moveTo(c.x+38,c.y+16); ctx.lineTo(c.x+38,c.y+44); ctx.lineTo(c.x+62,c.y+30); ctx.closePath(); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+62,c.y+16); ctx.lineTo(c.x+62,c.y+44); ctx.stroke();
                ctx.shadowBlur=0;
                label('LED',c.x+43,c.y+56);
            }
            else if(c.type==='MOTOR'){
                baseRect(c,dW,dH);
                ctx.strokeStyle=c.state!==0&&!c.burned?C_GREEN:'rgba(255,255,255,0.15)'; ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.arc(c.x+50,c.y+30,15,0,Math.PI*2); ctx.stroke();
                ctx.fillStyle=C_TEXT; ctx.font="bold 11px 'DM Mono'"; ctx.fillText('M',c.x+47,c.y+34);
                if(c.state!==0&&!c.burned){
                    ctx.save(); ctx.translate(c.x+50,c.y+30); ctx.rotate(rotAnim*c.state);
                    ctx.strokeStyle='rgba(0,230,118,0.6)'; ctx.lineWidth=1;
                    ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*0.7); ctx.stroke();
                    ctx.fillStyle=C_GREEN; ctx.beginPath(); ctx.moveTo(20,-4); ctx.lineTo(25,4); ctx.lineTo(15,4); ctx.fill();
                    ctx.restore();
                }
            }
            else if(c.type==='SWITCH'||c.type==='PUSH_BTN'){
                baseRect(c,dW,dH);
                ctx.strokeStyle=c.closed?C_GREEN:'rgba(255,255,255,0.2)'; ctx.lineWidth=1.2;
                if(c.closed){ctx.shadowBlur=6;ctx.shadowColor='rgba(0,230,118,0.3)';}
                ctx.beginPath(); ctx.moveTo(c.x+18,c.y+30);
                if(c.closed)ctx.lineTo(c.x+82,c.y+30); else ctx.lineTo(c.x+65,c.y+14); ctx.stroke(); ctx.shadowBlur=0;
                if(c.type==='PUSH_BTN'){
                    ctx.fillStyle=c.closed?C_GREEN:'rgba(255,255,255,0.2)';
                    ctx.beginPath(); ctx.arc(c.x+50,c.y+50,4,0,Math.PI*2); ctx.fill();
                }
                label(c.type==='SWITCH'?'SW':'BTN',c.x+40,c.y+10);
            }
            else if(c.type==='RELAY'){
                baseRect(c,dW,dH);
                ctx.strokeStyle=c.coilState?C_GREEN:'rgba(255,255,255,0.15)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(c.x+12,c.y+15);
                for(let i=0;i<4;i++){ctx.arc(c.x+12,c.y+20+(i*6),3,Math.PI*1.5,Math.PI*0.5,false);ctx.arc(c.x+12,c.y+23+(i*6),3,Math.PI*0.5,Math.PI*1.5,true);}
                ctx.lineTo(c.x+12,c.y+45); ctx.stroke();
                ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.moveTo(c.x+88,c.y+20); if(c.coilState)ctx.lineTo(c.x+88,c.y+40); else ctx.lineTo(c.x+78,c.y+34); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+88,c.y+40); ctx.lineTo(c.x+88,c.y+45); ctx.stroke();
                label('COIL',c.x+18,c.y+32); label('SW',c.x+70,c.y+32);
            }
            else if(c.type==='MUX'){
                const sel=c.selState;
                ctx.fillStyle='rgba(0,212,255,0.04)'; ctx.strokeStyle=sel?C_CYAN:'rgba(0,212,255,0.3)'; ctx.lineWidth=1;
                ctx.beginPath(); ctx.moveTo(c.x+22,c.y+10); ctx.lineTo(c.x+78,c.y+20); ctx.lineTo(c.x+78,c.y+40); ctx.lineTo(c.x+22,c.y+50); ctx.closePath(); ctx.fill(); ctx.stroke();
                ctx.fillStyle=sel?C_TEXT2:C_CYAN; ctx.beginPath(); ctx.arc(c.x+32,c.y+22,3,0,Math.PI*2); ctx.fill();
                ctx.fillStyle=sel?C_CYAN:C_TEXT2; ctx.beginPath(); ctx.arc(c.x+32,c.y+38,3,0,Math.PI*2); ctx.fill();
                label('MUX',c.x+37,c.y+33,C_CYAN,9);
                label('A',c.x+5,c.y+16); label('B',c.x+5,c.y+42); label('S',c.x+44,c.y+55); label('Q',c.x+82,c.y+33);
            }
            else if(c.type==='RSK90'){
                baseRect(c,dW,dH,'rgba(255,183,0,0.04)');
                ctx.strokeStyle=c.active?C_AMBER:'rgba(255,183,0,0.2)'; ctx.lineWidth=1;
                ctx.strokeRect(c.x+14,c.y+8,72,44);
                ctx.fillStyle=c.clockState?C_AMBER:'rgba(255,183,0,0.2)';
                if(c.clockState){ctx.shadowBlur=8;ctx.shadowColor='rgba(255,183,0,0.5)';}
                ctx.beginPath(); ctx.arc(c.x+50,c.y+30,5,0,Math.PI*2); ctx.fill(); ctx.shadowBlur=0;
                label('RSK90',c.x+34,c.y+24,C_AMBER,9);
                label('VCC',c.x+18,c.y+17); label('GND',c.x+18,c.y+45); label('OUT',c.x+60,c.y+35);
            }
            else if(c.type==='RADION'){
                const cW=c.w, cH=c.h;
                ctx.fillStyle='rgba(14,30,22,0.88)';
                ctx.strokeStyle=c.active?'rgba(0,230,118,0.45)':'rgba(0,230,118,0.15)';
                ctx.lineWidth=1;
                ctx.fillRect(c.x+28,c.y+4,54,cH-8);
                ctx.strokeRect(c.x+28,c.y+4,54,cH-8);
                ctx.fillStyle='rgba(0,0,0,0.3)';
                ctx.fillRect(c.x+34,c.y+20,40,cH-40);
                ctx.strokeStyle='rgba(0,230,118,0.12)';
                ctx.strokeRect(c.x+34,c.y+20,40,cH-40);
                ctx.save(); ctx.translate(c.x+46,c.y+cH*0.62); ctx.rotate(-Math.PI/2);
                label('RADION 1.1',0,0,'rgba(0,230,118,0.45)',7); ctx.restore();
                if(c.active&&!c.burned){
                    ctx.fillStyle=C_GREEN; ctx.shadowBlur=6; ctx.shadowColor=C_GREEN;
                    ctx.beginPath(); ctx.arc(c.x+66,c.y+25,2.5,0,Math.PI*2); ctx.fill();
                    ctx.shadowBlur=0;
                }
                label('VCC',c.x+1,c.y+18,'rgba(0,230,118,0.6)',8);
                label('GND',c.x+1,c.y+38,'rgba(255,71,87,0.6)',8);
                label('GND',c.x+1,c.y+58,'rgba(255,71,87,0.5)',8);
                label('A1', c.x+3,c.y+78,'rgba(255,183,0,0.75)',8);
                label('D1',c.x+83,c.y+18,C_GREEN,8);
                label('D2',c.x+83,c.y+38,C_GREEN,8);
                label('D3',c.x+83,c.y+58,C_GREEN,8);
                label('D4',c.x+83,c.y+78,'rgba(0,212,255,0.85)',8);
                label('SCL',c.x+81,c.y+98,C_AMBER,8);
                label('SDA',c.x+81,c.y+118,C_AMBER,8);
                const pinDots=[['d1',c.x+38,c.y+30],['d2',c.x+38,c.y+42],['d3',c.x+38,c.y+54],['d4',c.x+38,c.y+66]];
                pinDots.forEach(([k,px,py])=>{
                    const on=c.memory&&c.memory[k];
                    ctx.fillStyle=k==='d4'?(on?'rgba(0,212,255,0.9)':'rgba(255,255,255,0.06)'):(on?C_GREEN:'rgba(255,255,255,0.06)');
                    if(on){ctx.shadowBlur=5;ctx.shadowColor=k==='d4'?'rgba(0,212,255,0.7)':C_GREEN;}
                    ctx.beginPath(); ctx.arc(px,py,2.5,0,Math.PI*2); ctx.fill();
                    ctx.shadowBlur=0;
                });
                ctx.fillStyle='rgba(255,183,0,0.25)';
                ctx.fillRect(c.x+38,c.y+75,12,7);
                ctx.fillStyle='rgba(255,183,0,0.6)'; ctx.font="6px 'DM Mono',monospace";
                ctx.fillText('A1',c.x+39,c.y+82);
            }
            else if(c.type==='SERVO'){
                const powered = c.active && !c.burned;
                const bodyX = c.x+5, bodyY = c.y+22, bodyW = 80, bodyH = 42;
                const hubX  = c.x + 45, hubY = c.y + 22;

                ctx.fillStyle  = powered ? 'rgba(20,26,46,0.95)' : 'rgba(20,24,38,0.88)';
                ctx.strokeStyle= powered ? 'rgba(0,212,255,0.55)' : 'rgba(0,212,255,0.15)';
                ctx.lineWidth  = 1;
                ctx.fillRect(bodyX, bodyY, bodyW, bodyH);
                ctx.strokeRect(bodyX, bodyY, bodyW, bodyH);

                ctx.fillStyle  = powered ? 'rgba(10,18,40,0.95)' : 'rgba(12,16,30,0.9)';
                ctx.strokeStyle= powered ? 'rgba(0,212,255,0.4)' : 'rgba(0,212,255,0.1)';
                ctx.beginPath(); ctx.arc(hubX, hubY, 12, Math.PI, 0);
                ctx.fill(); ctx.stroke();

                ctx.strokeStyle = 'rgba(0,212,255,0.07)';
                ctx.lineWidth   = 1;
                ctx.beginPath(); ctx.arc(hubX, hubY, 26, Math.PI, 0); ctx.stroke();

                [[Math.PI,'0Â°'],[Math.PI*1.5,'90Â°'],[0,'180Â°']].forEach(([a,t])=>{
                    const mx=hubX+Math.cos(a)*29, my=hubY+Math.sin(a)*29;
                    ctx.fillStyle='rgba(0,212,255,0.2)'; ctx.font="5px 'DM Mono',monospace";
                    ctx.textAlign='center'; ctx.fillText(t,mx,my+2);
                });
                ctx.textAlign='left';

                const ang    = Math.PI - ((c.angle || 90) * Math.PI / 180);
                const armLen = 28;
                const tipX   = hubX + Math.cos(ang) * armLen;
                const tipY   = hubY + Math.sin(ang) * armLen;

                if(powered){
                    ctx.shadowBlur  = 8;
                    ctx.shadowColor = 'rgba(0,212,255,0.5)';
                }
                ctx.strokeStyle = powered ? 'rgba(0,212,255,0.9)' : 'rgba(255,255,255,0.25)';
                ctx.lineWidth   = 3.5; ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(hubX, hubY); ctx.lineTo(tipX, tipY); ctx.stroke();
                ctx.shadowBlur  = 0; ctx.lineCap = 'butt';

                ctx.fillStyle = powered ? 'rgba(0,212,255,1)' : 'rgba(255,255,255,0.3)';
                ctx.beginPath(); ctx.arc(tipX, tipY, 3.5, 0, Math.PI*2); ctx.fill();

                ctx.fillStyle   = powered ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.3)';
                ctx.strokeStyle = powered ? 'rgba(0,212,255,0.6)' : 'rgba(255,255,255,0.1)';
                ctx.lineWidth   = 1;
                ctx.beginPath(); ctx.arc(hubX, hubY, 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();

                [[bodyX+8, bodyY+8],[bodyX+bodyW-8,bodyY+8],[bodyX+8,bodyY+bodyH-8],[bodyX+bodyW-8,bodyY+bodyH-8]].forEach(([sx,sy])=>{
                    ctx.strokeStyle='rgba(255,255,255,0.12)'; ctx.lineWidth=0.7;
                    ctx.beginPath(); ctx.arc(sx,sy,3,0,Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(sx-2,sy); ctx.lineTo(sx+2,sy); ctx.moveTo(sx,sy-2); ctx.lineTo(sx,sy+2); ctx.stroke();
                });

                const goingCCW = ang > Math.PI;
                ctx.strokeStyle = powered ? 'rgba(0,212,255,0.35)' : 'rgba(255,255,255,0.08)';
                ctx.lineWidth   = 2;
                ctx.beginPath();
                ctx.arc(hubX, hubY, 20, Math.PI, ang, goingCCW); ctx.stroke();

                ctx.fillStyle = 'rgba(0,212,255,0.4)'; ctx.font = "7px 'DM Mono',monospace";
                ctx.fillText('SG90', bodyX+6, bodyY+16);

                const degText = Math.round(c.angle || 90) + 'Â°';
                ctx.fillStyle = powered ? 'rgba(0,212,255,0.85)' : 'rgba(255,255,255,0.3)';
                ctx.font = "bold 9px 'DM Mono',monospace";
                ctx.fillText(degText, bodyX+bodyW-24, bodyY+16);

                label('VCC', c.x+8,  c.y+12, 'rgba(0,230,118,0.6)', 7);
                label('GND', c.x+35, c.y+12, 'rgba(255,71,87,0.6)',  7);
                label('SIG', c.x+62, c.y+12, 'rgba(0,212,255,0.7)',  7);
            }
            else if(c.type==='L298N'){
                ctx.fillStyle='rgba(20,14,36,0.9)';
                ctx.strokeStyle=c.active&&!c.burned?'rgba(167,139,250,0.55)':'rgba(167,139,250,0.2)';
                ctx.lineWidth=1;
                ctx.fillRect(c.x,c.y,c.w,c.h); ctx.strokeRect(c.x,c.y,c.w,c.h);
                ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.fillRect(c.x+20,c.y+18,90,54);
                ctx.strokeStyle='rgba(167,139,250,0.2)'; ctx.strokeRect(c.x+20,c.y+18,90,54);
                ctx.fillStyle='rgba(167,139,250,0.7)'; ctx.font="bold 10px 'DM Mono',monospace";
                ctx.fillText('L298N',c.x+42,c.y+40);
                ctx.fillStyle='rgba(167,139,250,0.35)'; ctx.font="7px 'DM Mono',monospace";
                ctx.fillText('MOTOR DRIVER',c.x+30,c.y+54);
                const in1=c.nodes[2].signal, in2=c.nodes[3].signal;
                ctx.fillStyle=in1?'rgba(0,230,118,0.8)':'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.arc(c.x+35,c.y+65,4,0,Math.PI*2); ctx.fill();
                ctx.fillStyle=in2?'rgba(0,230,118,0.8)':'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.arc(c.x+55,c.y+65,4,0,Math.PI*2); ctx.fill();
                ctx.fillStyle='rgba(167,139,250,0.4)'; ctx.font="7px 'DM Mono',monospace";
                ctx.fillText('IN1',c.x+28,c.y+78); ctx.fillText('IN2',c.x+48,c.y+78);
                const dir=c.motorDir;
                if(dir!==0&&!c.burned){
                    ctx.fillStyle='rgba(167,139,250,0.7)';
                    ctx.font="9px 'DM Mono',monospace";
                    ctx.fillText(dir===1?'â†’ FWD':'â† REV',c.x+70,c.y+68);
                    ctx.shadowBlur=6; ctx.shadowColor='rgba(167,139,250,0.5)';
                    ctx.strokeStyle='rgba(167,139,250,0.6)'; ctx.lineWidth=1.5;
                    ctx.beginPath(); ctx.arc(c.x+95,c.y+44,8,0,Math.PI*0.75*dir+Math.PI*(dir===-1?1:0)); ctx.stroke();
                    ctx.shadowBlur=0;
                }
                label('VCC',c.x-22,c.y+23,'rgba(0,230,118,0.6)');
                label('GND',c.x-22,c.y+53,'rgba(255,71,87,0.5)');
                label('IN1',c.x-22,c.y+78,'rgba(167,139,250,0.6)');
                label('IN2',c.x+8, c.y+103,'rgba(167,139,250,0.6)');
                label('OUT1',c.x+133,c.y+33,'rgba(0,230,118,0.6)');
                label('OUT2',c.x+133,c.y+73,'rgba(0,230,118,0.6)');
            }
            else if(c.type==='OLED_I2C'){
                ctx.fillStyle='rgba(18,26,46,0.85)'; ctx.strokeStyle=c.burned?C_RED:C_BORD; ctx.lineWidth=1;
                ctx.fillRect(c.x,c.y,c.w,c.h); ctx.strokeRect(c.x,c.y,c.w,c.h);
                ctx.fillStyle='rgba(0,0,0,0.7)'; ctx.fillRect(c.x+4,c.y+14,c.w-8,c.h-18);
                ctx.strokeStyle='rgba(255,255,255,0.05)'; ctx.strokeRect(c.x+4,c.y+14,c.w-8,c.h-18);
                label('VCC',c.x+10,c.y+11); label('GND',c.x+37,c.y+11); label('SCL',c.x+62,c.y+11,C_AMBER); label('SDA',c.x+88,c.y+11,C_AMBER);
                if(c.active&&!c.burned&&c.initialized&&c.textLines){
                    ctx.fillStyle='rgba(0,230,118,0.85)'; ctx.font="9.5px 'DM Mono',monospace";
                    ctx.shadowBlur=3; ctx.shadowColor='rgba(0,230,118,0.4)';
                    for(let i=0;i<c.textLines.length;i++) ctx.fillText(c.textLines[i],c.x+7,c.y+26+(i*13));
                    ctx.shadowBlur=0;
                }
            }
            else if(c.type==='BATTERY'){
                baseRect(c,dW,dH);
                ctx.fillStyle='rgba(0,212,255,0.04)'; ctx.fillRect(c.x+10,c.y+16,75,28);
                ctx.strokeStyle=c.active&&!c.burned?'rgba(0,212,255,0.5)':'rgba(255,255,255,0.1)'; ctx.lineWidth=1;
                ctx.strokeRect(c.x+10,c.y+16,75,28);
                ctx.fillStyle='rgba(255,255,255,0.1)'; ctx.fillRect(c.x+85,c.y+22,5,16);
                ctx.fillStyle=c.active&&!c.burned?C_CYAN:C_TEXT;
                ctx.font="bold 12px 'DM Mono'"; ctx.fillText(`${c.val}V`,c.x+37,c.y+35);
                label('BATT',c.x+42,c.y+54);
            }
            else if(c.type==='CAPACITOR'){
                baseRect(c,dW,dH);
                const pct=c.charge/100;
                ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.moveTo(c.x+35,c.y+10); ctx.lineTo(c.x+35,c.y+50); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+50,c.y+10); ctx.lineTo(c.x+50,c.y+50); ctx.stroke();
                ctx.fillStyle='rgba(0,212,255,0.1)'; ctx.fillRect(c.x+38,c.y+12,10,36);
                ctx.fillStyle=`rgba(0,212,255,${0.3+pct*0.5})`; ctx.fillRect(c.x+38,c.y+12+(36*(1-pct)),10,36*pct);
                label(`${Math.floor(c.charge)}%`,c.x+32,c.y+62,C_CYAN);
                label(`${c.val}ÂµF`,c.x+32,c.y+8);
            }
            else if(c.type==='TRANSISTOR'){
                baseRect(c,dW,dH);
                ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.arc(c.x+50,c.y+30,18,0,Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+42,c.y+15); ctx.lineTo(c.x+42,c.y+45); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+42,c.y+30); ctx.lineTo(c.x+22,c.y+50); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+42,c.y+20); ctx.lineTo(c.x+62,c.y+10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+42,c.y+40); ctx.lineTo(c.x+80,c.y+30); ctx.stroke();
                ctx.fillStyle='rgba(255,255,255,0.6)';
                if(c.mode==='NPN'){ctx.beginPath();ctx.moveTo(c.x+70,c.y+32);ctx.lineTo(c.x+60,c.y+35);ctx.lineTo(c.x+62,c.y+28);ctx.fill();}
                else{ctx.beginPath();ctx.moveTo(c.x+47,c.y+39);ctx.lineTo(c.x+57,c.y+36);ctx.lineTo(c.x+55,c.y+43);ctx.fill();}
                label(c.mode,c.x+36,c.y+33,C_TEXT);
                label('C',c.x+26,c.y+14); label('E',c.x+70,c.y+24); label('B',c.x+26,c.y+48);
            }
            else if(c.type==='RESISTOR'){
                baseRect(c,dW,dH);
                ctx.strokeStyle=c.burned?C_RED:'rgba(255,183,0,0.5)'; ctx.lineWidth=1.2;
                ctx.beginPath(); ctx.moveTo(c.x+16,c.y+30); ctx.lineTo(c.x+27,c.y+20); ctx.lineTo(c.x+37,c.y+40); ctx.lineTo(c.x+47,c.y+20); ctx.lineTo(c.x+57,c.y+40); ctx.lineTo(c.x+67,c.y+30); ctx.stroke();
                label(`${c.val}Î©`,c.x+34,c.y+13,C_AMBER);
            }
            else if(['AND','OR','NOT','XOR'].includes(c.type)){
                const ac=c.active&&!c.burned;
                ctx.fillStyle=ac?'rgba(0,212,255,0.06)':'rgba(255,255,255,0.03)';
                ctx.strokeStyle=ac?'rgba(0,212,255,0.6)':(c.burned?C_RED:'rgba(255,255,255,0.15)'); ctx.lineWidth=1.2;
                if(c.type==='AND'){ctx.beginPath();ctx.moveTo(c.x+28,c.y+14);ctx.lineTo(c.x+62,c.y+14);ctx.arc(c.x+62,c.y+30,16,-Math.PI/2,Math.PI/2);ctx.lineTo(c.x+28,c.y+46);ctx.closePath();ctx.fill();ctx.stroke();}
                else if(c.type==='OR'){ctx.beginPath();ctx.moveTo(c.x+28,c.y+14);ctx.quadraticCurveTo(c.x+50,c.y+14,c.x+72,c.y+30);ctx.quadraticCurveTo(c.x+50,c.y+46,c.x+28,c.y+46);ctx.quadraticCurveTo(c.x+46,c.y+30,c.x+28,c.y+14);ctx.fill();ctx.stroke();}
                else if(c.type==='XOR'){ctx.beginPath();ctx.moveTo(c.x+34,c.y+14);ctx.quadraticCurveTo(c.x+56,c.y+14,c.x+72,c.y+30);ctx.quadraticCurveTo(c.x+56,c.y+46,c.x+34,c.y+46);ctx.quadraticCurveTo(c.x+50,c.y+30,c.x+34,c.y+14);ctx.fill();ctx.stroke();ctx.beginPath();ctx.moveTo(c.x+26,c.y+14);ctx.quadraticCurveTo(c.x+42,c.y+30,c.x+26,c.y+46);ctx.stroke();}
                else if(c.type==='NOT'){ctx.beginPath();ctx.moveTo(c.x+28,c.y+14);ctx.lineTo(c.x+70,c.y+30);ctx.lineTo(c.x+28,c.y+46);ctx.closePath();ctx.fill();ctx.stroke();ctx.beginPath();ctx.arc(c.x+73,c.y+30,3,0,Math.PI*2);ctx.stroke();label('PWR',c.x+3,c.y+12);label('IN',c.x+5,c.y+55);}
                label(c.type,c.x+(c.type==='NOT'?37:30),c.y+33,ac?C_CYAN:'rgba(255,255,255,0.2)',9);
            }

            if(c.burned){
                ctx.fillStyle='rgba(255,71,87,0.07)'; ctx.fillRect(c.x,c.y,dW,dH);
                ctx.fillStyle=C_RED; ctx.font="8px 'DM Mono'"; ctx.fillText('BURNED',c.x+dW/2-20,c.y-4);
            }

            ctx.restore();

            c.nodes.forEach(n=>{
                let nc='rgba(255,255,255,0.15)';
                if(n.id==='+'||n.id==='A'||n.id==='M1'||n.id==='R1'||n.id==='I1'||n.id==='I2'||n.id==='PWR'||n.id==='IN'||n.id==='C+'||n.id==='VCC')nc='rgba(0,230,118,0.6)';
                else if(n.id==='-'||n.id==='C'||n.id==='M2'||n.id==='R2'||n.id==='GND'||n.id==='G')nc='rgba(255,71,87,0.5)';
                if(c.type==='TRANSISTOR'||c.type==='MUX'||n.id==='S'||n.id==='COM'||n.id==='OUT')nc='rgba(0,212,255,0.5)';
                if(c.type==='RADION'&&(n.id==='D1'||n.id==='D2'||n.id==='D3'))nc='rgba(0,230,118,0.7)';
                if((c.type==='RADION'||c.type==='OLED_I2C')&&(n.id==='SCL'||n.id==='SDA'))nc='rgba(255,183,0,0.6)';
                if(c.type==='RELAY'&&n.id==='NO')nc='rgba(255,71,87,0.5)';
                if(c.type==='L298N'&&(n.id==='IN1'||n.id==='IN2'))nc='rgba(167,139,250,0.6)';
                if(c.type==='L298N'&&(n.id==='OUT1'||n.id==='OUT2'))nc='rgba(0,230,118,0.6)';

                ctx.fillStyle=nc;
                ctx.beginPath(); ctx.arc(c.x+n.x,c.y+n.y,4,0,Math.PI*2); ctx.fill();
                if(n.signal){
                    ctx.strokeStyle='rgba(0,212,255,0.8)'; ctx.lineWidth=1;
                    ctx.shadowBlur=5; ctx.shadowColor='rgba(0,212,255,0.5)';
                    ctx.beginPath(); ctx.arc(c.x+n.x,c.y+n.y,6,0,Math.PI*2); ctx.stroke();
                    ctx.shadowBlur=0;
                }
            });
        });

        if(selectionBox){
            ctx.strokeStyle='rgba(0,212,255,0.5)'; ctx.lineWidth=1; ctx.setLineDash([3,3]);
            ctx.strokeRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h);
            ctx.fillStyle='rgba(0,212,255,0.04)'; ctx.fillRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h);
            ctx.setLineDash([]);
        }

        if(isDesktopMode){
            ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
            ctx.beginPath(); ctx.arc(vMouse.x,vMouse.y,5,0,Math.PI*2); ctx.stroke();
            ctx.strokeStyle='rgba(255,255,255,0.1)';
            ctx.beginPath(); ctx.moveTo(vMouse.x-12,vMouse.y); ctx.lineTo(vMouse.x-6,vMouse.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(vMouse.x+6,vMouse.y); ctx.lineTo(vMouse.x+12,vMouse.y); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(vMouse.x,vMouse.y-12); ctx.lineTo(vMouse.x,vMouse.y-6); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(vMouse.x,vMouse.y+6); ctx.lineTo(vMouse.x,vMouse.y+12); ctx.stroke();
        }

        ctx.restore();

        ctx.fillStyle='rgba(255,255,255,0.08)';
        ctx.font="9px 'DM Mono',monospace";
        ctx.textAlign='right';
        ctx.fillText('Simulic Pro v1.8',canvas.width-14,canvas.height-12);
        ctx.textAlign='left';

        requestAnimationFrame(draw);
    }

    draw();
</script>

</body>
</html>
