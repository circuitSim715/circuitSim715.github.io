<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Simulic Pro - Manual Update</title>
    <style>
        * { user-select: none; box-sizing: border-box; touch-action: none; }
        body { margin: 0; background: #050505; color: #00ff41; font-family: 'Courier New', monospace; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        /* UI SUPERIOR */
        #ui-top { padding: 10px; background: #111; display: flex; justify-content: flex-start; gap: 5px; border-bottom: 1px solid #222; z-index: 10; overflow-x: auto; }
        #ui-sub { padding: 8px; background: #1a1a1a; display: flex; gap: 6px; border-bottom: 2px solid #00ff41; min-height: 45px; overflow-x: auto; align-items: center; z-index: 9; }
        
        .cat-btn { padding: 8px 12px; background: #000; border: 1px solid #444; color: #aaa; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: bold; flex-shrink: 0; }
        .cat-btn.active { background: #00ff41; color: #000; border-color: #00ff41; box-shadow: 0 0 10px rgba(0,255,65,0.4); }
        
        .cat-btn-demo { border-color: #9b59b6; color: #9b59b6; }
        .cat-btn-demo.active { background: #9b59b6; color: #fff; box-shadow: 0 0 10px rgba(155, 89, 182, 0.4); }

        .cat-btn-manual { border-color: #f1c40f; color: #f1c40f; }
        .cat-btn-manual:active { background: #f1c40f; color: #000; }

        .spawn-btn { padding: 6px 10px; background: #222; border: 1px solid #555; color: #ddd; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: bold; flex-shrink: 0; white-space: nowrap; }
        .spawn-btn:active { background: #fff; color: #000; }
        
        .clear-btn { margin-left: auto; border-color: #e74c3c; color: #e74c3c; background: #111; } 
        .mode-btn { border-color: #3498db; color: #3498db; background: #111; margin-left: 5px; }

        #canvas-container { flex: 1; position: relative; overflow: hidden; background: #050505; cursor: crosshair; }
        canvas { width: 100%; height: 100%; display: block; }
        
        #zoom-controls { position: absolute; right: 15px; top: 15px; display: flex; flex-direction: column; gap: 10px; z-index: 20; }
        .zoom-btn { padding: 10px; font-size: 16px; width: 45px; height: 45px; display: flex; align-items: center; justify-content: center; background: #111; border: 2px solid #3498db; color: #3498db; border-radius: 50%; cursor: pointer; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.5); }
        .zoom-btn:active { background: #3498db; color: #000; transform: scale(0.9); }

        /* CONTROLES VIRTUALES (M√ìVIL) */
        #virtual-controls { background: #111; height: 180px; display: flex; justify-content: space-between; padding: 10px; border-top: 2px solid #222; z-index: 10; transition: height 0.3s; }
        .dpad { display: grid; grid-template-columns: repeat(3, 50px); grid-template-rows: repeat(2, 50px); gap: 8px; }
        .btn-v { background: #1a1a1a; border: 1px solid #333; border-radius: 8px; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; cursor: pointer; }
        .btn-up { grid-column: 2; } .btn-left { grid-column: 1; grid-row: 2; } .btn-down { grid-column: 2; grid-row: 2; } .btn-right { grid-column: 3; grid-row: 2; }
        
        .actions { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr); gap: 8px; }
        .btn-action { width: 55px; height: 55px; border-radius: 50%; font-weight: bold; font-size: 9px; color: white; border: none; cursor: pointer; }
        .btn-click { background: #2ecc71; } .btn-del { background: #e74c3c; } 
        .btn-use { background: #f1c40f; color: black; } .btn-cfg { background: #9b59b6; } .btn-rot { background: #e67e22; }
        .btn-sel { background: #3498db; }
        .btn-action:active { transform: scale(0.9); }
        
        /* MODAL CONFIGURACI√ìN */
        #modal { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #111; border: 2px solid #00ff41; padding: 20px; text-align: center; z-index: 100; border-radius: 8px; box-shadow: 0 0 20px rgba(0,255,65,0.2); width: 300px; }
        #modal input { width: 100px; padding: 5px; background: #000; color: #00ff41; border: 1px solid #00ff41; text-align: center; margin: 10px 0; font-size: 16px; font-family: monospace; }
        #m-code-area { width: 100%; height: 150px; background: #000; color: #fff; border: 1px solid #555; font-family: monospace; font-size: 11px; text-align: left; padding: 5px; margin-bottom: 10px; resize: none; display: none; white-space: pre; overflow-wrap: normal; overflow-x: auto; }
        
        .modal-btn { padding: 8px 15px; background: #1a1a1a; border: 1px solid #00ff41; color: #00ff41; cursor: pointer; margin: 5px; border-radius: 4px; }
        .modal-btn-rep { border-color: #f1c40f; color: #f1c40f; }
        .modal-btn-toggle { border-color: #3498db; color: #3498db; }

        /* PANTALLA DE MANUAL */
        #manual-screen { display: none; position: absolute; top: 5%; left: 5%; width: 90%; height: 90%; background: rgba(10,10,10,0.95); border: 2px solid #f1c40f; z-index: 300; padding: 20px; overflow-y: auto; color: #ddd; box-shadow: 0 0 50px rgba(0,0,0,0.9); }
        #manual-screen h2 { color: #f1c40f; border-bottom: 1px solid #f1c40f; padding-bottom: 10px; }
        #manual-screen h4 { color: #00ff41; margin-top: 20px; margin-bottom: 5px; }
        #manual-screen p, #manual-screen li { font-size: 13px; line-height: 1.5; color: #ccc; }
        #manual-screen code { background: #222; padding: 2px 5px; color: #e67e22; border-radius: 3px; }
        #manual-screen .close-manual { position: absolute; top: 10px; right: 10px; background: #e74c3c; color: white; border: none; padding: 5px 10px; cursor: pointer; font-weight: bold; }

        /* MEN√ö CONTEXTUAL (CLICK DERECHO) */
        #context-menu { display: none; position: absolute; background: #222; border: 1px solid #00ff41; z-index: 200; box-shadow: 2px 2px 10px rgba(0,0,0,0.8); border-radius: 4px; min-width: 120px; }
        .ctx-item { padding: 8px 12px; color: #eee; cursor: pointer; font-size: 12px; border-bottom: 1px solid #333; }
        .ctx-item:hover { background: #00ff41; color: #000; }
        .ctx-item:last-child { border-bottom: none; }

        .desktop-mode #virtual-controls { display: none !important; }
        .desktop-mode #zoom-controls { top: auto; bottom: 20px; right: 20px; }
    </style>
</head>
<body class="">

<div id="ui-top">
    <button class="cat-btn" onclick="selectCategory('active', this)">ACTIVOS</button>
    <button class="cat-btn" onclick="selectCategory('passive', this)">PASIVOS</button>
    <button class="cat-btn" onclick="selectCategory('digital', this)">DIGITALES</button>
    <button class="cat-btn" onclick="selectCategory('boards', this)">PLACAS</button>
    <button class="cat-btn cat-btn-demo" onclick="selectCategory('demos', this)">‚òÖ DEMOS</button>
    <button class="cat-btn cat-btn-manual" onclick="toggleManual()">üìñ MANUAL</button>
    <button class="clear-btn mode-btn" onclick="toggleMode()" id="btnMode">üì± M√ìVIL</button>
    <button class="clear-btn" onclick="clearAll()">BORRAR TODO</button> 
</div>
<div id="ui-sub">
    <span style="color:#444; font-size:10px;">SELECCIONA UNA CATEGOR√çA ARRIBA</span>
</div>

<div id="canvas-container" oncontextmenu="return false;">
    <div id="zoom-controls">
        <button class="zoom-btn" onclick="camera.zoom = Math.min(3.0, camera.zoom + 0.2)">üîé+</button>
        <button class="zoom-btn" onclick="camera.zoom = 1.0" style="font-size: 12px;">1x</button>
        <button class="zoom-btn" onclick="camera.zoom = Math.max(0.4, camera.zoom - 0.2)">üîé-</button>
    </div>
    <canvas id="circuitCanvas"></canvas>
    
    <div id="modal">
        <h3 id="m-title" style="margin:0 0 10px 0;">Configurar</h3>
        <input type="number" id="m-val"> <span id="m-unit"></span>
        <textarea id="m-code-area" spellcheck="false" placeholder="Escribe c√≥digo LOG aqu√≠..."></textarea>
        <br>
        <button class="modal-btn modal-btn-toggle" id="m-toggle" onclick="toggleCompType()" style="display:none;">TIPO: NPN</button>
        <br>
        <button class="modal-btn" onclick="saveCfg()">GUARDAR</button>
        <button class="modal-btn" onclick="closeCfg()">CERRAR</button>
        <button class="modal-btn modal-btn-rep" id="m-repair" onclick="repairCfg()" style="display:none;">REPARAR</button>
    </div>

    <div id="manual-screen">
        <button class="close-manual" onclick="toggleManual()">CERRAR [X]</button>
        <h2>MANUAL DE USUARIO - SIMULIC PRO</h2>
        
        <h4>1. INTRODUCCI√ìN</h4>
        <p>Bienvenido a Simulic Pro, un entorno de simulaci√≥n electr√≥nica donde la f√≠sica importa. Aqu√≠ puedes crear circuitos complejos, l√≥gica digital y automatizaci√≥n.</p>

        <h4>2. ¬°IMPORTANTE! ¬øPOR QU√â SE QUEMAN MIS COSAS?</h4>
        <p style="color:#e74c3c; font-weight:bold;">ESTO NO ES UN ERROR, ES F√çSICA.</p>
        <p>Al igual que en la vida real, los componentes tienen l√≠mites:</p>
        <ul>
            <li>Un <strong>LED</strong> conectado directo a una bater√≠a de 9V <strong>explotar√°</strong>. Necesita una resistencia (aprox 330Œ©).</li>
            <li>Un <strong>Transistor</strong> sin resistencia en la base se quemar√°.</li>
            <li>Si algo se pone ROJO o dice "QUEMADO", usa la herramienta <strong>AJUSTAR</strong> (o click derecho) y pulsa <strong>REPARAR</strong>.</li>
        </ul>

        <h4>3. PROGRAMACI√ìN 'LOG' (CHIP RADION)</h4>
        <p>El componente RADION es programable. Usa el lenguaje LOG:</p>
        <ul>
            <li><code>start&lt;</code> : Inicia el c√≥digo.</li>
            <li><code>end&gt;</code> : Termina el c√≥digo.</li>
            <li><code>pinA=D1</code> : Asigna el pin f√≠sico D1 a la variable 'pinA'.</li>
            <li><code>pinA;HIGH</code> : Enciende el pin (5V).</li>
            <li><code>pinA;LOW</code> : Apaga el pin (0V).</li>
            <li><code>delay 500</code> : Espera 500 milisegundos.</li>
            <li><code>loop</code> : Vuelve al inicio (crea un bucle infinito).</li>
        </ul>
        <p><em>Ejemplo Parpadeo:</em><br>
        <code>start&lt;<br>var=D1<br>var;HIGH<br>delay 500<br>var;LOW<br>delay 500<br>loop<br>end&gt;</code></p>
    </div>

    <div id="context-menu">
        <div class="ctx-item" onclick="ctxAction('use')">üëÜ Usar</div>
        <div class="ctx-item" onclick="ctxAction('cfg')">‚öôÔ∏è Ajustar</div>
        <div class="ctx-item" onclick="ctxAction('rot')">üîÑ Rotar</div>
        <div class="ctx-item" onclick="ctxAction('del')" style="color:#e74c3c">üóëÔ∏è Borrar</div>
    </div>
</div>

<div id="virtual-controls">
    <div class="dpad">
        <div class="btn-v btn-up" id="vUp">‚ñ≤</div>
        <div class="btn-v btn-left" id="vLeft">‚óÄ</div>
        <div class="btn-v btn-down" id="vDown">‚ñº</div>
        <div class="btn-v btn-right" id="vRight">‚ñ∂</div>
    </div>
    <div class="actions">
        <button class="btn-action btn-click" id="vClick">CABLE</button>
        <button class="btn-action btn-use" id="vUse">USAR</button>
        <button class="btn-action btn-rot" id="vRot">ROTAR</button>
        <button class="btn-action btn-cfg" id="vCfg">AJUSTAR</button>
        <button class="btn-action btn-del" id="vDel">BORRAR</button>
        <button class="btn-action btn-sel" id="vSel">SELECT</button>
    </div>
</div>

<script>
    let isDesktopMode = false;

    function toggleMode() {
        isDesktopMode = !isDesktopMode;
        const body = document.body;
        const btn = document.getElementById('btnMode');
        
        if (isDesktopMode) {
            body.classList.add('desktop-mode');
            btn.innerText = "üñ•Ô∏è PC";
            btn.style.borderColor = "#00ff41";
            btn.style.color = "#00ff41";
        } else {
            body.classList.remove('desktop-mode');
            btn.innerText = "üì± M√ìVIL";
            btn.style.borderColor = "#3498db";
            btn.style.color = "#3498db";
        }
        resize();
    }

    function toggleManual() {
        const m = document.getElementById('manual-screen');
        m.style.display = (m.style.display === 'block') ? 'none' : 'block';
    }

    // --- LISTAS DE COMPONENTES Y DEMOS ---
    const componentLists = {
        'active': [
            { id: 'BATTERY', label: 'BATER√çA' },
            { id: 'LED', label: 'LED' },
            { id: 'MOTOR', label: 'MOTOR' },
            { id: 'TRANSISTOR', label: 'TRANSISTOR' },
            { id: 'RELAY', label: 'REL√â' }
        ],
        'passive': [
            { id: 'SWITCH', label: 'INTERRUPTOR' },
            { id: 'PUSH_BTN', label: 'BOT√ìN' },
            { id: 'RESISTOR', label: 'RESISTENCIA' },
            { id: 'CAPACITOR', label: 'CONDENSADOR' }
        ],
        'digital': [
            { id: 'RSK90', label: 'CHIP RSK90' },
            { id: 'AND', label: 'AND' },
            { id: 'OR', label: 'OR' },
            { id: 'XOR', label: 'XOR' },
            { id: 'NOT', label: 'NOT' },
            { id: 'MUX', label: 'MULTIPLEXOR' }
        ],
        'boards': [
            { id: 'RADION', label: 'RADION 1.0' }
        ]
    };

    // DEFINICI√ìN DE DEMOS
    const demos = {
        'EMPTY': { label: 'VAC√çO (LIMPIAR)', func: () => { clearAll(true); } },
        'BASIC': { label: 'ELECTRICIDAD B√ÅSICA', func: () => loadBasicDemo() },
        'LOGIC': { label: 'PUERTA AND', func: () => loadLogicDemo() },
        'MOTOR': { label: 'CONTROL MOTOR', func: () => loadMotorDemo() },
        'RADION': { label: 'RADION BLINK', func: () => loadRadionDemo() }
    };

    function selectCategory(cat, btnElement) {
        document.querySelectorAll('.cat-btn').forEach(b => b.classList.remove('active'));
        if(btnElement && !btnElement.classList.contains('cat-btn-manual')) btnElement.classList.add('active');
        const sub = document.getElementById('ui-sub');
        sub.innerHTML = '';

        if (cat === 'demos') {
            Object.keys(demos).forEach(key => {
                const d = demos[key];
                const btn = document.createElement('button');
                btn.className = 'spawn-btn';
                btn.innerText = d.label;
                btn.style.borderColor = '#9b59b6';
                btn.onclick = d.func;
                sub.appendChild(btn);
            });
        } else {
            componentLists[cat].forEach(comp => {
                const btn = document.createElement('button');
                btn.className = 'spawn-btn';
                btn.innerText = comp.label;
                btn.onclick = () => spawn(comp.id);
                if (cat === 'digital') btn.style.borderColor = '#3498db';
                if (comp.id === 'RSK90') btn.style.color = '#e67e22';
                if (comp.id === 'RADION') { btn.style.borderColor = '#2ecc71'; btn.style.color = '#2ecc71'; }
                sub.appendChild(btn);
            });
        }
    }
    
    // Funci√≥n auxiliar para conectar cables
    function connect(c1, pin1, c2, pin2) {
        const n1 = c1.nodes[pin1];
        const n2 = c2.nodes[pin2];
        if (n1 && n2) {
            connections.push({ a: {c:c1, n:n1}, b: {c:c2, n:n2} });
        }
    }

    function loadBasicDemo() {
        clearAll(true);
        camera.x = 0; camera.y = 0; camera.zoom = 1.0;
        
        const bat = spawn('BATTERY', -150, -50);
        const res = spawn('RESISTOR', -20, -100);
        const sw = spawn('SWITCH', -20, 0);
        const led = spawn('LED', 120, -50);

        connect(bat, 0, res, 0); 
        connect(res, 1, led, 0); 
        connect(led, 1, sw, 1);  
        connect(sw, 0, bat, 1);  
        
        sw.closed = true;
    }

    function loadLogicDemo() {
        clearAll(true);
        camera.x = 0; camera.y = 0;
        
        // CORRECCI√ìN: A√±adida resistencia para no quemar el LED de salida
        const sw1 = spawn('SWITCH', -180, -80);
        const sw2 = spawn('SWITCH', -180, 20);
        const andGate = spawn('AND', -30, -30);
        const res = spawn('RESISTOR', 100, -30); // Resistencia de protecci√≥n
        res.val = 220;
        const led = spawn('LED', 200, -30);
        const bat = spawn('BATTERY', -250, 150);

        connect(bat, 0, sw1, 0);
        connect(bat, 0, sw2, 0);
        connect(sw1, 1, andGate, 0);
        connect(sw2, 1, andGate, 1);
        
        // Salida AND -> Resistencia -> LED
        connect(andGate, 2, res, 0);
        connect(res, 1, led, 0);
        connect(led, 1, bat, 1); 
    }

    function loadMotorDemo() {
        clearAll(true);
        // CORRECCI√ìN: Resistencia peque√±a para limitar corriente del motor
        const bat = spawn('BATTERY', -120, -50);
        const res = spawn('RESISTOR', -20, -120); // Resistencia limitadora
        res.val = 10; // Valor bajo para dejar girar el motor pero protegerlo algo
        const btn = spawn('PUSH_BTN', 60, -50);
        const motor = spawn('MOTOR', 60, 50);
        
        connect(bat, 0, res, 0);
        connect(res, 1, motor, 0);
        connect(motor, 1, btn, 0);
        connect(btn, 1, bat, 1);
    }

    function loadRadionDemo() {
        clearAll(true);
        const radion = spawn('RADION', -50, -50);
        const led1 = spawn('LED', 150, -80);
        const led2 = spawn('LED', 150, 20);
        const bat = spawn('BATTERY', -200, 0);
        
        connect(bat, 0, radion, 0); 
        connect(bat, 1, radion, 1); 
        
        // El chip RADION tiene salidas reguladas (en la l√≥gica interna), 
        // pero para ense√±ar buenos h√°bitos, podr√≠amos poner resistencias.
        // En este caso, asumimos que el chip tiene l√≥gica interna de 5v.
        connect(radion, 3, led1, 0); 
        connect(led1, 1, radion, 2); 
        
        connect(radion, 4, led2, 0); 
        connect(led2, 1, radion, 2); 
        
        radion.code = "start<\npin1=D1\npin2=D2\npin1;HIGH\ndelay 200\npin1;LOW\npin2;HIGH\ndelay 200\npin2;LOW\nloop\nend>";
        radion.intState = { pc: 0, wait: 0, vars: {} };
    }

    selectCategory('active', document.querySelector('.cat-btn'));

    // --- MOTOR F√çSICO ---
    const canvas = document.getElementById('circuitCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    let components = [], connections = [];
    const vMouse = { x: 0, y: 0, speed: 4, isDown: false, lastDown: false, moving: {}, selectionMode: false };
    let draggingComp = null, drawingCable = null, rotAnim = 0, time = 0;
    let targetCfg = null;
    let selectionBox = null; 
    let selectedItems = []; 
    let camera = { x: 0, y: 0, zoom: 1.0 };
    let contextTarget = null;
    let isPanning = false; 

    function resize() { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }
    window.addEventListener('resize', resize); resize();

    // --- INPUT HANDLERS ---
    
    canvas.addEventListener('wheel', (e) => {
        if (!isDesktopMode) return;
        e.preventDefault();
        const delta = Math.sign(e.deltaY) * -0.1;
        camera.zoom = Math.min(3.0, Math.max(0.4, camera.zoom + delta));
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDesktopMode) return;
        if (isPanning) {
            camera.x -= e.movementX / camera.zoom;
            camera.y -= e.movementY / camera.zoom;
            return; 
        }
        const rect = canvas.getBoundingClientRect();
        vMouse.x = ((e.clientX - rect.left) / camera.zoom) + camera.x - (canvas.width / 2) / camera.zoom;
        vMouse.y = ((e.clientY - rect.top) / camera.zoom) + camera.y - (canvas.height / 2) / camera.zoom;

        if (selectionBox) {
            selectionBox.w = vMouse.x - selectionBox.x;
            selectionBox.h = vMouse.y - selectionBox.y;
        }
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!isDesktopMode) return;
        if (e.button === 1) {
            e.preventDefault();
            isPanning = true;
            canvas.style.cursor = 'grabbing';
            return;
        }
        if (e.button !== 0) return; 
        
        document.getElementById('context-menu').style.display = 'none';

        let nHit = null;
        components.forEach(c => c.nodes.forEach(n => { if (Math.hypot(c.x+n.x-vMouse.x, c.y+n.y-vMouse.y) < 20) nHit = {c, n}; }));
        
        if (nHit) {
            drawingCable = nHit;
        } else {
            let compHit = components.find(c => vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h);
            if (compHit) {
                if (selectedItems.includes(compHit)) { 
                    draggingComp = { group: true, ref: compHit, ox: vMouse.x, oy: vMouse.y }; 
                } else { 
                    selectedItems.forEach(c => c.selected = false); selectedItems = []; 
                    draggingComp = {c: compHit, ox:vMouse.x-compHit.x, oy:vMouse.y-compHit.y}; 
                }
            } else {
                selectedItems.forEach(c => c.selected = false); selectedItems = [];
                selectionBox = { x: vMouse.x, y: vMouse.y, w: 0, h: 0 };
            }
        }
    });

    canvas.addEventListener('contextmenu', (e) => {
        if (!isDesktopMode) return;
        e.preventDefault();
        
        let compHit = components.find(c => vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h);
        
        if (compHit) {
            contextTarget = compHit;
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = e.clientX + 'px';
            menu.style.top = e.clientY + 'px';
        } else {
            document.getElementById('context-menu').style.display = 'none';
        }
    });

    canvas.addEventListener('mouseup', (e) => {
        if (!isDesktopMode) return;
        if (e.button === 1) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
            return;
        }
        
        if (drawingCable) {
            let targetHit = null;
            components.forEach(c => c.nodes.forEach(n => { if (c!==drawingCable.c && Math.hypot(c.x+n.x-vMouse.x, c.y+n.y-vMouse.y) < 20) targetHit = {c, n}; }));
            if (targetHit) connections.push({a:drawingCable, b:targetHit});
            else { const waypoint = spawn('WAYPOINT'); connections.push({a:drawingCable, b:{c:waypoint, n:waypoint.nodes[0]}}); }
        }

        if (selectionBox) {
            applySelection();
            selectionBox = null;
        }

        draggingComp = drawingCable = null;
    });

    function ctxAction(action) {
        document.getElementById('context-menu').style.display = 'none';
        if (!contextTarget) return;

        if (action === 'del') {
            components = components.filter(c => c !== contextTarget);
            connections = connections.filter(conn => components.includes(conn.a.c) && components.includes(conn.b.c));
            if(selectedItems.includes(contextTarget)) selectedItems = [];
        } else if (action === 'rot') {
            rotateComponent(contextTarget);
        } else if (action === 'cfg') {
            openCfg(contextTarget);
        } else if (action === 'use') {
             if (contextTarget.type === 'SWITCH' || contextTarget.type === 'PUSH_BTN') {
                 contextTarget.closed = !contextTarget.closed;
             }
        }
        contextTarget = null;
    }

    const bind = (id, k) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => { if(isDesktopMode) return; e.preventDefault(); vMouse.moving[k] = true; });
        el.addEventListener('touchend', (e) => { if(isDesktopMode) return; e.preventDefault(); vMouse.moving[k] = false; });
        el.addEventListener('mousedown', () => { if(isDesktopMode) return; vMouse.moving[k] = true; });
        el.addEventListener('mouseup', () => { if(isDesktopMode) return; vMouse.moving[k] = false; });
    };
    bind('vUp', 'up'); bind('vDown', 'down'); bind('vLeft', 'left'); bind('vRight', 'right');

    const setupBtn = (id, fn) => {
        const el = document.getElementById(id);
        el.addEventListener('mousedown', () => { if(!isDesktopMode) fn(true); }); el.addEventListener('mouseup', () => { if(!isDesktopMode) fn(false); });
        el.addEventListener('touchstart', (e) => { if(!isDesktopMode) { e.preventDefault(); fn(true); } }); el.addEventListener('touchend', (e) => { if(!isDesktopMode) { e.preventDefault(); fn(false); } });
    };
    setupBtn('vClick', (v) => vMouse.isDown = v);
    
    setupBtn('vSel', (v) => {
        vMouse.selectionMode = v;
        if (v) { selectionBox = { x: vMouse.x, y: vMouse.y, w: 0, h: 0 }; } 
        else {
            if (selectionBox && Math.abs(selectionBox.w) > 5) applySelection();
            selectionBox = null;
        }
    });

    function clearAll(force = false) { 
        if(force || confirm("¬øBorrar todo?")) { 
            components = []; connections = []; selectedItems = []; drawingCable = null; 
        } 
    }

    function applySelection() {
        if (!selectionBox) return;
        let bx = selectionBox.w > 0 ? selectionBox.x : selectionBox.x + selectionBox.w;
        let by = selectionBox.h > 0 ? selectionBox.y : selectionBox.y + selectionBox.h;
        let bw = Math.abs(selectionBox.w); let bh = Math.abs(selectionBox.h);
        components.filter(c => c.x + c.w > bx && c.x < bx + bw && c.y + c.h > by && c.y < by + bh).forEach(c => {
            if(!selectedItems.includes(c)) { c.selected = true; selectedItems.push(c); }
        });
    }

    function distToSegment(p, v, w) {
        const l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
        if (l2 === 0) return Math.hypot(p.x - v.x, p.y - v.y);
        let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
        return Math.hypot(p.x - projection.x, p.y - projection.y);
    }

    document.getElementById('vDel').addEventListener('click', () => {
        if (selectedItems.length > 0) {
            components = components.filter(c => !selectedItems.includes(c));
            connections = connections.filter(conn => components.includes(conn.a.c) && components.includes(conn.b.c));
            selectedItems = []; return; 
        }
        let cableDeleted = false;
        connections = connections.filter(conn => {
            if(cableDeleted) return true;
            const p1 = {x: conn.a.c.x + conn.a.n.x, y: conn.a.c.y + conn.a.n.y};
            const p2 = {x: conn.b.c.x + conn.b.n.x, y: conn.b.c.y + conn.b.n.y};
            if (distToSegment(vMouse, p1, p2) < 10) { cableDeleted = true; return false; }
            return true;
        });
        if(!cableDeleted) {
            components = components.filter(c => !(vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h));
            connections = connections.filter(conn => components.includes(conn.a.c) && components.includes(conn.b.c));
        }
    });

    document.getElementById('vRot').addEventListener('click', () => {
        if(selectedItems.length > 0) { selectedItems.forEach(c => { if(c.type !== 'WAYPOINT') rotateComponent(c); }); } 
        else {
            const hit = components.find(c => vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h);
            if (hit && hit.type !== 'WAYPOINT') rotateComponent(hit);
        }
    });

    function rotateComponent(c) {
        c.rotation = (c.rotation + 1) % 4;
        const cx = c.w / 2; const cy = c.h / 2;
        c.nodes.forEach(n => { const dx = n.x - cx; const dy = n.y - cy; n.x = cx - dy; n.y = cy + dx; });
        [c.w, c.h] = [c.h, c.w];
    }
    
    const vUseBtn = document.getElementById('vUse');
    const handleUse = (active) => {
        components.filter(c => c.type === 'PUSH_BTN').forEach(c => {
            if(vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h) c.closed = active;
            if(!active) c.closed = false;
        });
        if (active) {
            components.forEach(c => { 
                if(c.type==='SWITCH' && vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h) c.closed = !c.closed; 
            });
        }
    };
    vUseBtn.addEventListener('mousedown', () => handleUse(true));
    vUseBtn.addEventListener('mouseup', () => handleUse(false));
    vUseBtn.addEventListener('touchstart', (e) => { e.preventDefault(); handleUse(true); });
    vUseBtn.addEventListener('touchend', (e) => { e.preventDefault(); handleUse(false); });

    document.getElementById('vCfg').addEventListener('click', () => {
        if (selectedItems.length > 1) return;
        const hit = components.find(c => vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h);
        if (hit) openCfg(hit);
    });

    function openCfg(c) { 
        targetCfg=c; 
        document.getElementById('modal').style.display='block'; 
        document.getElementById('m-title').innerText=c.type; 
        const isBatResCap = c.type==='BATTERY'||c.type==='RESISTOR'||c.type==='CAPACITOR';
        document.getElementById('m-val').style.display=isBatResCap?'inline-block':'none'; 
        if(isBatResCap) document.getElementById('m-val').value=c.val||0; 
        
        let unit = '';
        if(c.type==='BATTERY') unit='V'; else if(c.type==='RESISTOR') unit='Œ©'; else if(c.type==='CAPACITOR') unit='uF';
        document.getElementById('m-unit').innerText=unit; 
        document.getElementById('m-repair').style.display=c.burned?'inline-block':'none';
        
        const toggleBtn = document.getElementById('m-toggle');
        if (c.type === 'TRANSISTOR') { toggleBtn.style.display = 'inline-block'; toggleBtn.innerText = "TIPO: " + c.mode; } 
        else { toggleBtn.style.display = 'none'; }

        const codeArea = document.getElementById('m-code-area');
        if (c.type === 'RADION') {
            codeArea.style.display = 'block';
            codeArea.value = c.code;
            c.intState = { pc: 0, wait: 0, vars: {} }; 
        } else {
            codeArea.style.display = 'none';
        }
    }
    
    function toggleCompType() {
        if (targetCfg && targetCfg.type === 'TRANSISTOR') {
            targetCfg.mode = targetCfg.mode === 'NPN' ? 'PNP' : 'NPN';
            document.getElementById('m-toggle').innerText = "TIPO: " + targetCfg.mode;
        }
    }

    function closeCfg() { document.getElementById('modal').style.display='none'; targetCfg=null; }
    
    function saveCfg() { 
        if(targetCfg) {
            if (targetCfg.type === 'BATTERY' || targetCfg.type === 'RESISTOR' || targetCfg.type === 'CAPACITOR') { 
                targetCfg.val = Math.max(0.1, parseFloat(document.getElementById('m-val').value) || 0); 
            } 
            if (targetCfg.type === 'RADION') {
                targetCfg.code = document.getElementById('m-code-area').value;
                targetCfg.intState = { pc: 0, wait: 0, vars: {} };
            }
        }
        closeCfg(); 
    }
    function repairCfg() { if(targetCfg) targetCfg.burned=false; closeCfg(); }

    function spawn(type, xOpt, yOpt) {
        const tx = (xOpt !== undefined) ? xOpt : vMouse.x;
        const ty = (yOpt !== undefined) ? yOpt : vMouse.y;

        const comp = { type, x: tx-50, y: ty-30, w: 100, h: 60, nodes: [], state: 0, active: false, burned: false, rotation: 0, selected: false };
        if (type === 'BATTERY') { comp.nodes = [{id:'+', x:0, y:30}, {id:'-', x:100, y:30}]; comp.val = 9; }
        else if (type === 'LED') comp.nodes = [{id:'A', x:0, y:30}, {id:'C', x:100, y:30}];
        else if (type === 'MOTOR') comp.nodes = [{id:'M1', x:0, y:30}, {id:'M2', x:100, y:30}];
        else if (type === 'SWITCH' || type === 'PUSH_BTN') { comp.closed = false; comp.nodes = [{id:'1', x:0, y:30}, {id:'2', x:100, y:30}]; } 
        else if (type === 'CAPACITOR') { comp.nodes = [{id:'+', x:0, y:30}, {id:'-', x:100, y:30}]; comp.charge = 0; comp.val = 10; }
        else if (type === 'TRANSISTOR') { comp.nodes = [{id:'C', x:20, y:10}, {id:'B', x:20, y:50}, {id:'E', x:80, y:30}]; comp.mode = 'NPN'; }
        else if (type === 'RESISTOR') { comp.nodes = [{id:'R1', x:0, y:30}, {id:'R2', x:100, y:30}]; comp.val = 330; }
        else if (type === 'RELAY') { comp.nodes = [{id:'C+', x:10, y:15}, {id:'C-', x:10, y:45}, {id:'COM', x:90, y:20}, {id:'NO', x:90, y:40}]; comp.coilState = false; }
        else if (type === 'MUX') {
            comp.nodes = [{id:'A', x:0, y:15}, {id:'B', x:0, y:45}, {id:'S', x:50, y:50}, {id:'OUT', x:100, y:30}];
            comp.selState = false;
        }
        else if (type === 'AND' || type === 'OR' || type === 'XOR') comp.nodes = [{id:'I1', x:0, y:15}, {id:'I2', x:0, y:45}, {id:'OUT', x:100, y:30}]; 
        else if (type === 'NOT') comp.nodes = [{id:'PWR', x:0, y:15}, {id:'IN', x:0, y:45}, {id:'OUT', x:100, y:30}];
        else if (type === 'RSK90') {
            comp.nodes = [{id:'VCC', x:20, y:10}, {id:'GND', x:20, y:50}, {id:'OUT', x:80, y:30}];
            comp.lastTick = 0; comp.clockState = false;
        }
        else if (type === 'RADION') {
            comp.w = 110; comp.h = 90;
            comp.nodes = [
                {id:'VCC', x:15, y:15}, {id:'GND', x:15, y:45},
                {id:'G', x:15, y:75}, {id:'D1', x:95, y:30}, {id:'D2', x:95, y:60}
            ];
            comp.code = "start<\npin1=D1\npin1;HIGH\ndelay 500\npin1;LOW\ndelay 500\nloop\nend>";
            comp.memory = { d1: false, d2: false };
            comp.intState = { pc: 0, wait: 0, vars: {} };
        }
        else if (type === 'WAYPOINT') { comp.x = tx-5; comp.y = ty-5; comp.w=10; comp.h=10; comp.nodes=[{id:'W', x:5, y:5}]; }
        components.push(comp);
        return comp;
    }

    function runRadionLogic(c) {
        if (!c.active || c.burned) {
            c.memory.d1 = false; c.memory.d2 = false;
            c.intState = { pc: 0, wait: 0, vars: {} };
            return;
        }
        if (!c.intState) c.intState = { pc: 0, wait: 0, vars: {} };
        
        const now = Date.now();
        if (c.intState.wait > now) return;

        const rawLines = c.code.split('\n');
        let instructionsExecuted = 0;
        const maxInstructions = 20;

        while(instructionsExecuted < maxInstructions) {
            if (c.intState.pc >= rawLines.length) break;

            let line = rawLines[c.intState.pc].trim();
            if (!line || line.startsWith('//')) { c.intState.pc++; continue; }

            if (line.includes('start<')) { c.intState.pc++; }
            else if (line.includes('end>')) { break; }
            else if (line === 'loop') {
                 const startIndex = rawLines.findIndex(l => l.trim().includes('start<'));
                 c.intState.pc = startIndex !== -1 ? startIndex + 1 : 0;
                 instructionsExecuted++;
            }
            else if (line.startsWith('delay')) {
                 const parts = line.split(' ');
                 const ms = parseInt(parts[1]) || 100;
                 c.intState.wait = now + ms;
                 c.intState.pc++;
                 return;
            }
            else if (line.includes('=')) {
                const parts = line.split('=');
                if (parts.length === 2) c.intState.vars[parts[0].trim()] = parts[1].trim();
                c.intState.pc++;
            }
            else if (line.includes(';')) {
                const parts = line.split(';');
                const varName = parts[0].trim();
                const state = parts[1].trim();
                const physicalPin = c.intState.vars[varName];
                if (physicalPin === 'D1') c.memory.d1 = (state === 'HIGH');
                if (physicalPin === 'D2') c.memory.d2 = (state === 'HIGH');
                c.intState.pc++;
            }
            else { c.intState.pc++; }
            instructionsExecuted++;
        }
    }

    function updatePhysics() {
        components.forEach(c => { 
            c.state = 0; 
            if(c.type !== 'CAPACITOR') c.active = false; 
            if(c.type === 'RELAY') c.coilActiveThisFrame = false; 
        });
        connections.forEach(conn => { conn.active = false; conn.flowDir = 1; });

        components.filter(c => c.type === 'CAPACITOR').forEach(cap => {
            if (cap.charge > 0) cap.isSource = true;
            else { cap.isSource = false; cap.active = false; }
        });

        components.forEach(c => c.nodes.forEach(n => n.signal = false));
        
        const sources = components.filter(c => 
            (c.type === 'BATTERY' || 
             (c.type === 'CAPACITOR' && c.isSource) || 
             (c.type === 'RSK90' && c.clockState) ||
             (c.type === 'RADION' && (c.memory.d1 || c.memory.d2))) 
            && !c.burned
        );

        sources.forEach(src => {
            let startNodes = [];
            if (src.type === 'BATTERY' || src.type === 'CAPACITOR') startNodes.push(src.nodes[0]);
            else if (src.type === 'RSK90') startNodes.push(src.nodes[2]);
            else if (src.type === 'RADION') {
                if (src.memory.d1) startNodes.push(src.nodes[3]);
                if (src.memory.d2) startNodes.push(src.nodes[4]);
            }

            startNodes.forEach(startNode => {
                let q = [startNode]; startNode.signal = true;
                while(q.length > 0) {
                    let curr = q.shift();
                    connections.forEach(conn => {
                        let next = null; if (conn.a.n === curr) next = conn.b.n; if (conn.b.n === curr) next = conn.a.n;
                        if (next && !next.signal) { next.signal = true; q.push(next); }
                    });
                    const comp = components.find(c => c.nodes.includes(curr));
                    if (comp && !comp.burned) {
                        if ((comp.type === 'SWITCH' || comp.type === 'PUSH_BTN') && !comp.closed) continue;
                        if (comp.type === 'RELAY') { if ((curr === comp.nodes[2] || curr === comp.nodes[3]) && !comp.coilState) continue; }
                        if (comp.type === 'MUX') {
                            const sel = comp.selState;
                            if (curr === comp.nodes[0]) { if (!sel && !comp.nodes[3].signal) { comp.nodes[3].signal=true; q.push(comp.nodes[3]); } }
                            else if (curr === comp.nodes[1]) { if (sel && !comp.nodes[3].signal) { comp.nodes[3].signal=true; q.push(comp.nodes[3]); } }
                            else if (curr === comp.nodes[3]) {
                                let dest = sel ? comp.nodes[1] : comp.nodes[0];
                                if(!dest.signal) { dest.signal=true; q.push(dest); }
                            }
                            continue; 
                        }
                        if (comp.type === 'LED' && curr !== comp.nodes[0]) continue;
                        if (comp.type === 'CAPACITOR' && curr !== comp.nodes[0]) continue; 
                        if (comp.type === 'TRANSISTOR') continue;
                        if (['AND', 'OR', 'NOT', 'XOR', 'RSK90', 'RADION'].includes(comp.type)) continue; 
                        comp.nodes.forEach(n => { if (!n.signal) { n.signal = true; q.push(n); } });
                    }
                }
            });
        });

        components.filter(c => (c.type === 'BATTERY' || (c.type === 'CAPACITOR' && c.isSource)) && !c.burned).forEach(bat => {
            let foundPaths = [];
            function dfs(currentNode, currentPath, visitedNodes) {
                if (currentNode === bat.nodes[1]) { foundPaths.push([...currentPath]); return; }
                connections.forEach(conn => {
                    if (conn.a.n === currentNode && !visitedNodes.includes(conn.b.n)) dfs(conn.b.n, [...currentPath, {t: 'wire', c: conn, dir: 1}], [...visitedNodes, conn.b.n]);
                    if (conn.b.n === currentNode && !visitedNodes.includes(conn.a.n)) dfs(conn.a.n, [...currentPath, {t: 'wire', c: conn, dir: -1}], [...visitedNodes, conn.a.n]);
                });
                const comp = components.find(c => c.nodes.includes(currentNode));
                if (comp && comp !== bat && !comp.burned) {
                    let outNodes = [];
                    let direction = (currentNode === comp.nodes[0]) ? 1 : -1;
                    if (comp.type === 'TRANSISTOR') {
                        if (currentNode === comp.nodes[0]) outNodes.push(comp.nodes[2]);
                        else if (currentNode === comp.nodes[2]) outNodes.push(comp.nodes[0]);
                    }
                    else if (['AND', 'OR', 'NOT', 'XOR'].includes(comp.type)) { if (currentNode === comp.nodes[0] || currentNode === comp.nodes[1]) outNodes.push(comp.nodes[2]); } 
                    else if (comp.type === 'RELAY') {
                        if (currentNode === comp.nodes[0]) outNodes.push(comp.nodes[1]);
                        if (currentNode === comp.nodes[1]) outNodes.push(comp.nodes[0]);
                        if (currentNode === comp.nodes[2]) outNodes.push(comp.nodes[3]);
                        if (currentNode === comp.nodes[3]) outNodes.push(comp.nodes[2]);
                    }
                    else if (comp.type === 'MUX') {
                        const sel = comp.selState;
                        if (currentNode === comp.nodes[0] && !sel) outNodes.push(comp.nodes[3]);
                        if (currentNode === comp.nodes[1] && sel) outNodes.push(comp.nodes[3]);
                        if (currentNode === comp.nodes[3]) {
                            if (sel) outNodes.push(comp.nodes[1]); else outNodes.push(comp.nodes[0]);
                        }
                    }
                    else if (comp.type === 'RSK90') {
                        if (currentNode === comp.nodes[0]) { outNodes.push(comp.nodes[1]); outNodes.push(comp.nodes[2]); } 
                        if (currentNode === comp.nodes[1]) outNodes.push(comp.nodes[0]);
                        if (currentNode === comp.nodes[2]) outNodes.push(comp.nodes[0]); 
                    }
                    else if (comp.type === 'RADION') {
                        if (currentNode === comp.nodes[0]) { outNodes.push(comp.nodes[1]); outNodes.push(comp.nodes[2]); }
                        if (currentNode === comp.nodes[1]) { outNodes.push(comp.nodes[2]); outNodes.push(comp.nodes[0]); }
                        if (currentNode === comp.nodes[2]) { outNodes.push(comp.nodes[1]); outNodes.push(comp.nodes[0]); }
                        if (comp.memory.d1) {
                             if (currentNode === comp.nodes[0]) outNodes.push(comp.nodes[3]); 
                             if (currentNode === comp.nodes[3]) outNodes.push(comp.nodes[0]); 
                        }
                        if (comp.memory.d2) {
                             if (currentNode === comp.nodes[0]) outNodes.push(comp.nodes[4]); 
                             if (currentNode === comp.nodes[4]) outNodes.push(comp.nodes[0]); 
                        }
                    }
                    else { outNodes.push(comp.nodes.find(n => n !== currentNode)); }

                    outNodes.forEach(otherNode => {
                        if (otherNode && !visitedNodes.includes(otherNode)) {
                            let canCross = false;
                            if (comp.type === 'RESISTOR' || comp.type === 'MOTOR' || comp.type === 'WAYPOINT') canCross = true;
                            if ((comp.type === 'SWITCH' || comp.type === 'PUSH_BTN') && comp.closed) canCross = true;
                            if (comp.type === 'RELAY') {
                                if ((currentNode === comp.nodes[0] && otherNode === comp.nodes[1]) || (currentNode === comp.nodes[1] && otherNode === comp.nodes[0])) canCross = true;
                                if ((currentNode === comp.nodes[2] && otherNode === comp.nodes[3]) || (currentNode === comp.nodes[3] && otherNode === comp.nodes[2])) {
                                    if(comp.coilState) canCross = true;
                                }
                            }
                            if (comp.type === 'MUX') canCross = true; 
                            if (comp.type === 'LED' && direction === 1) canCross = true; 
                            if (comp.type === 'CAPACITOR' && bat.type === 'BATTERY') canCross = true;
                            if (comp.type === 'AND' && comp.nodes[0].signal && comp.nodes[1].signal) canCross = true;
                            if (comp.type === 'OR' && (comp.nodes[0].signal || comp.nodes[1].signal)) canCross = true;
                            if (comp.type === 'XOR' && ((comp.nodes[0].signal && !comp.nodes[1].signal) || (!comp.nodes[0].signal && comp.nodes[1].signal))) canCross = true;
                            if (comp.type === 'NOT' && currentNode === comp.nodes[0] && !comp.nodes[1].signal) canCross = true;
                            
                            if (comp.type === 'RSK90') {
                                if ((currentNode === comp.nodes[0] && otherNode === comp.nodes[1]) || (currentNode === comp.nodes[1] && otherNode === comp.nodes[0])) canCross = true;
                                if (comp.clockState && ((currentNode === comp.nodes[0] && otherNode === comp.nodes[2]) || (currentNode === comp.nodes[2] && otherNode === comp.nodes[0]))) canCross = true;
                            }
                            if (comp.type === 'RADION') {
                                const isPwr = (n) => n === comp.nodes[0] || n === comp.nodes[1] || n === comp.nodes[2];
                                if (isPwr(currentNode) && isPwr(otherNode)) canCross = true;
                                if (comp.memory.d1 && ((currentNode === comp.nodes[0] && otherNode === comp.nodes[3]) || (currentNode === comp.nodes[3] && otherNode === comp.nodes[0]))) canCross = true;
                                if (comp.memory.d2 && ((currentNode === comp.nodes[0] && otherNode === comp.nodes[4]) || (currentNode === comp.nodes[4] && otherNode === comp.nodes[0]))) canCross = true;
                            }

                            if (comp.type === 'TRANSISTOR') {
                                const baseSignal = comp.nodes[1].signal;
                                if (comp.mode === 'NPN') { if (baseSignal) canCross = true; } 
                                else { if (!baseSignal) canCross = true; }
                            }
                            if (canCross) dfs(otherNode, [...currentPath, {t: 'comp', comp, dir: direction}], [...visitedNodes, otherNode]);
                        }
                    });
                }
            }
            dfs(bat.nodes[0], [], [bat.nodes[0]]);
            if (foundPaths.length > 0) {
                if (bat.type === 'CAPACITOR') bat.charge -= 2.0; 
                foundPaths.forEach(path => {
                    let rSum = 0.1; let ledCount = 0; let pathComps = [];
                    path.forEach(step => {
                        if (step.t === 'comp') {
                            pathComps.push(step.comp);
                            if (step.comp.type === 'RESISTOR') rSum += step.comp.val;
                            if (step.comp.type === 'RELAY') rSum += 50; 
                            if (step.comp.type === 'RSK90') rSum += 1000;
                            if (step.comp.type === 'RADION') rSum += 1200;
                            if (step.comp.type === 'LED') ledCount++;
                            if (['AND', 'OR', 'NOT', 'XOR', 'MUX'].includes(step.comp.type)) rSum += 10;
                            if (step.comp.type === 'CAPACITOR' && bat.type === 'BATTERY') {
                                let chargeRate = 50 / (step.comp.val || 10);
                                step.comp.charge = Math.min(100, step.comp.charge + chargeRate); step.comp.active = true; 
                            }
                        }
                    });
                    let vNet = bat.val - (ledCount * 2); let current = vNet > 0 ? (vNet / rSum) : 0; let popped = false;
                    if (current > 0) {
                        if (bat.type === 'BATTERY' && current > 5.0) { bat.burned = true; popped = true; }
                        pathComps.forEach(c => {
                            if (c.type === 'LED' && current > 0.035) { c.burned = true; popped = true; }
                            if (c.type === 'RESISTOR' && (current * current * c.val) > 0.5) { c.burned = true; popped = true; }
                            if (['AND', 'OR', 'NOT', 'XOR', 'MUX'].includes(c.type) && current > 0.2) { c.burned = true; popped = true; }
                            if (c.type === 'TRANSISTOR' && current > 1.0) { c.burned = true; popped = true; }
                        });
                    }
                    if (!popped && current > 0) {
                        bat.active = true;
                        path.forEach(step => {
                            if (step.t === 'wire') { step.c.active = true; step.c.flowDir = step.dir; }
                            if (step.t === 'comp') {
                                step.comp.active = true;
                                if (step.comp.type === 'LED') step.comp.state = 1;
                                if (step.comp.type === 'MOTOR') step.comp.state = step.dir;
                                if (step.comp.type === 'RELAY') step.comp.coilActiveThisFrame = true;
                            }
                        });
                    }
                });
            }
        });
        
        components.filter(c => c.type === 'RELAY').forEach(r => r.coilState = r.coilActiveThisFrame);
        components.filter(c => c.type === 'MUX').forEach(m => { m.selState = m.nodes[2].signal; });

        components.filter(c => c.type === 'RSK90').forEach(c => {
            if (c.active && !c.burned) {
                const now = Date.now();
                if (!c.lastTick) c.lastTick = now;
                if (now - c.lastTick >= 1000) { 
                    c.clockState = !c.clockState;
                    c.lastTick = now;
                }
            } else { c.clockState = false; c.lastTick = 0; }
        });
        components.filter(c => c.type === 'RADION').forEach(c => { runRadionLogic(c); });
    }

    function drawGrid(camX, camY, zoom) {
        ctx.strokeStyle = "#222"; ctx.lineWidth = 1 / zoom; 
        const size = 50;
        const halfW = (canvas.width / 2) / zoom; const halfH = (canvas.height / 2) / zoom;
        const startX = Math.floor((camX - halfW) / size) * size - size; const endX = camX + halfW + size;
        const startY = Math.floor((camY - halfH) / size) * size - size; const endY = camY + halfH + size;
        ctx.beginPath();
        for(let x = startX; x < endX; x += size) { ctx.moveTo(x, startY); ctx.lineTo(x, endY); }
        for(let y = startY; y < endY; y += size) { ctx.moveTo(startX, y); ctx.lineTo(endX, y); }
        ctx.stroke();
    }

    function draw() {
        if(targetCfg == null && !isDesktopMode) { 
            if (vMouse.moving.up) vMouse.y -= vMouse.speed; if (vMouse.moving.down) vMouse.y += vMouse.speed;
            if (vMouse.moving.left) vMouse.x -= vMouse.speed; if (vMouse.moving.right) vMouse.x += vMouse.speed;
        }

        if(!isDesktopMode) { 
            const edgeMargin = 50; 
            let screenMouseX = (vMouse.x - camera.x) * camera.zoom + canvas.width / 2;
            let screenMouseY = (vMouse.y - camera.y) * camera.zoom + canvas.height / 2;
            if (screenMouseX < edgeMargin) camera.x -= (edgeMargin - screenMouseX) / camera.zoom;
            if (screenMouseX > canvas.width - edgeMargin) camera.x += (screenMouseX - (canvas.width - edgeMargin)) / camera.zoom;
            if (screenMouseY < edgeMargin) camera.y -= (edgeMargin - screenMouseY) / camera.zoom;
            if (screenMouseY > canvas.height - edgeMargin) camera.y += (screenMouseY - (canvas.height - edgeMargin)) / camera.zoom;
        }

        if (vMouse.selectionMode && selectionBox && !isDesktopMode) {
            selectionBox.w = vMouse.x - selectionBox.x; selectionBox.h = vMouse.y - selectionBox.y;
        }

        if (!isDesktopMode) {
             if (vMouse.isDown && !vMouse.lastDown && targetCfg == null && !vMouse.selectionMode) {
                let clickOnSomething = false; let nHit = null;
                components.forEach(c => c.nodes.forEach(n => { if (Math.hypot(c.x+n.x-vMouse.x, c.y+n.y-vMouse.y) < 20) nHit = {c, n}; }));
                if (nHit) { drawingCable = nHit; clickOnSomething = true; } 
                else {
                    let compHit = components.find(c => vMouse.x > c.x && vMouse.x < c.x+c.w && vMouse.y > c.y && vMouse.y < c.y+c.h);
                    if (compHit) {
                        clickOnSomething = true;
                        if (selectedItems.includes(compHit)) { draggingComp = { group: true, ref: compHit, ox: vMouse.x, oy: vMouse.y }; } 
                        else { selectedItems.forEach(c => c.selected = false); selectedItems = []; draggingComp = {c: compHit, ox:vMouse.x-compHit.x, oy:vMouse.y-compHit.y}; }
                    }
                }
                if (!clickOnSomething && selectedItems.length > 0) { selectedItems.forEach(c => c.selected = false); selectedItems = []; }
            } else if (!vMouse.isDown && vMouse.lastDown) {
                if (drawingCable) {
                    let targetHit = null;
                    components.forEach(c => c.nodes.forEach(n => { if (c!==drawingCable.c && Math.hypot(c.x+n.x-vMouse.x, c.y+n.y-vMouse.y) < 20) targetHit = {c, n}; }));
                    if (targetHit) connections.push({a:drawingCable, b:targetHit});
                    else { const waypoint = spawn('WAYPOINT'); connections.push({a:drawingCable, b:{c:waypoint, n:waypoint.nodes[0]}}); }
                }
                draggingComp = drawingCable = null;
            }
        }

        if (draggingComp) { 
            if (draggingComp.group) {
                const dx = vMouse.x - draggingComp.ox; const dy = vMouse.y - draggingComp.oy;
                selectedItems.forEach(c => { c.x += dx; c.y += dy; });
                draggingComp.ox = vMouse.x; draggingComp.oy = vMouse.y;
            } else { draggingComp.c.x = vMouse.x-draggingComp.ox; draggingComp.c.y = vMouse.y-draggingComp.oy; }
        }
        vMouse.lastDown = vMouse.isDown;
        
        updatePhysics();
        rotAnim += 0.2; time += 0.5;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        drawGrid(camera.x, camera.y, camera.zoom);

        connections.forEach(conn => {
            ctx.strokeStyle = conn.active ? "#00ff41" : "#333"; ctx.lineWidth = 3; 
            if (conn.active) { ctx.setLineDash([8, 8]); ctx.lineDashOffset = -time * conn.flowDir; } else { ctx.setLineDash([]); }
            ctx.beginPath(); ctx.moveTo(conn.a.c.x+conn.a.n.x, conn.a.c.y+conn.a.n.y); ctx.lineTo(conn.b.c.x+conn.b.n.x, conn.b.c.y+conn.b.n.y); ctx.stroke();
            ctx.setLineDash([]);
        });

        if (drawingCable) { ctx.strokeStyle = "#888"; ctx.beginPath(); ctx.moveTo(drawingCable.c.x+drawingCable.n.x, drawingCable.c.y+drawingCable.n.y); ctx.lineTo(vMouse.x, vMouse.y); ctx.stroke(); }

        components.forEach(c => {
            if (c.type === 'WAYPOINT') {
                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(c.x+c.nodes[0].x, c.y+c.nodes[0].y, 4, 0, Math.PI*2); ctx.fill(); return; 
            }

            ctx.save();
            ctx.translate(c.x + c.w/2, c.y + c.h/2);
            ctx.rotate(c.rotation * Math.PI/2);
            ctx.translate(-(c.x + c.w/2), -(c.y + c.h/2));

            if(c.selected || selectedItems.includes(c)) {
                let drawW = (c.rotation % 2 === 0) ? c.w : c.h; let drawH = (c.rotation % 2 === 0) ? c.h : c.w;
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.setLineDash([4,4]);
                ctx.strokeRect(c.x-5, c.y-5, drawW+10, drawH+10); ctx.setLineDash([]);
            }

            ctx.fillStyle = "#111"; ctx.strokeStyle = c.burned ? "#e74c3c" : "#444"; ctx.lineWidth = 2;
            let drawW = (c.rotation % 2 === 0) ? c.w : c.h; let drawH = (c.rotation % 2 === 0) ? c.h : c.w;
            
            if(c.type === 'RADION') ctx.fillStyle = "#27ae60"; 
            else ctx.fillStyle = "#111";

            ctx.fillRect(c.x, c.y, drawW, drawH); ctx.strokeRect(c.x, c.y, drawW, drawH);
            if(c.burned) { ctx.fillStyle = "#e74c3c"; ctx.font = "bold 12px Arial"; ctx.fillText("¬°QUEMADO!", c.x+5, c.y-5); }

            if (c.type === 'LED') {
                ctx.strokeStyle = c.state && !c.burned ? "yellow" : (c.burned ? "#311" : "#555");
                if (c.state && !c.burned) { ctx.shadowBlur = 10; ctx.shadowColor = "yellow"; }
                ctx.beginPath(); ctx.moveTo(c.x+40, c.y+20); ctx.lineTo(c.x+40, c.y+40); ctx.lineTo(c.x+60, c.y+30); ctx.closePath(); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+60, c.y+20); ctx.lineTo(c.x+60, c.y+40); ctx.stroke(); ctx.shadowBlur = 0;
            } else if (c.type === 'MOTOR') {
                ctx.strokeStyle = c.state !== 0 && !c.burned ? "#00ff41" : "#555";
                ctx.beginPath(); ctx.arc(c.x+50, c.y+30, 15, 0, Math.PI*2); ctx.stroke();
                ctx.fillStyle = "white"; ctx.font = "12px monospace"; ctx.fillText("M", c.x+47, c.y+34);
                if (c.state !== 0 && !c.burned) {
                    ctx.save(); ctx.translate(c.x+50, c.y+30); ctx.rotate(rotAnim * c.state); ctx.strokeStyle = "yellow"; 
                    ctx.beginPath(); ctx.arc(0,0, 22, 0, Math.PI*0.7); ctx.stroke(); ctx.fillStyle = "yellow"; 
                    ctx.beginPath(); ctx.moveTo(22,-5); ctx.lineTo(28,5); ctx.lineTo(16,5); ctx.fill(); ctx.restore();
                }
            } else if (c.type === 'SWITCH' || c.type === 'PUSH_BTN') {
                ctx.strokeStyle = "white"; ctx.beginPath(); ctx.moveTo(c.x+20, c.y+30);
                if (c.closed) ctx.lineTo(c.x+80, c.y+30); else ctx.lineTo(c.x+60, c.y+10); ctx.stroke();
                if(c.type === 'PUSH_BTN') { ctx.beginPath(); ctx.arc(c.x+50, c.y+50, 4, 0, Math.PI*2); ctx.fill(); }
            } else if (c.type === 'RELAY') {
                ctx.strokeStyle = c.coilState ? "#00ff41" : "#888"; 
                ctx.beginPath(); ctx.moveTo(c.x+10, c.y+15); 
                for(let i=0; i<4; i++) { ctx.arc(c.x+10, c.y+20+(i*6), 3, Math.PI*1.5, Math.PI*0.5, false); ctx.arc(c.x+10, c.y+23+(i*6), 3, Math.PI*0.5, Math.PI*1.5, true); }
                ctx.lineTo(c.x+10, c.y+45); ctx.stroke();
                ctx.strokeStyle = "white"; ctx.beginPath(); ctx.moveTo(c.x+90, c.y+20); 
                if (c.coilState) ctx.lineTo(c.x+90, c.y+40); else ctx.lineTo(c.x+80, c.y+35); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+90, c.y+40); ctx.lineTo(c.x+90, c.y+45); ctx.stroke();
                ctx.fillStyle = "#aaa"; ctx.font="8px Arial"; ctx.fillText("COIL", c.x+15, c.y+30); ctx.fillText("SW", c.x+70, c.y+30);
            } 
            else if (c.type === 'MUX') {
                ctx.strokeStyle = "#3498db"; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(c.x+20, c.y+10); ctx.lineTo(c.x+80, c.y+20); ctx.lineTo(c.x+80, c.y+40); ctx.lineTo(c.x+20, c.y+50);
                ctx.closePath(); ctx.stroke();
                const sel = c.selState;
                ctx.fillStyle = sel ? "#222" : "#00ff41"; ctx.beginPath(); ctx.arc(c.x+30, c.y+20, 3, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = sel ? "#00ff41" : "#222"; ctx.beginPath(); ctx.arc(c.x+30, c.y+40, 3, 0, Math.PI*2); ctx.fill(); 
                ctx.fillStyle = "#3498db"; ctx.font = "bold 10px monospace"; ctx.fillText("MUX", c.x+35, c.y+33);
                ctx.fillStyle = "#aaa"; ctx.font = "8px monospace"; 
                ctx.fillText("A", c.x+5, c.y+15); ctx.fillText("B", c.x+5, c.y+45); ctx.fillText("S", c.x+45, c.y+55); ctx.fillText("Q", c.x+85, c.y+33);
            }
            else if (c.type === 'RSK90') {
                ctx.strokeStyle = c.active ? "#e67e22" : "#555"; ctx.lineWidth = 2;
                ctx.strokeRect(c.x+15, c.y+10, 70, 40); ctx.fillStyle = "#222"; ctx.fillRect(c.x+15, c.y+10, 70, 40);
                ctx.fillStyle = c.clockState ? "#e67e22" : "#333"; ctx.beginPath(); ctx.arc(c.x+50, c.y+30, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#e67e22"; ctx.font = "bold 10px monospace"; ctx.fillText("RSK90", c.x+35, c.y+25);
                ctx.fillStyle = "#aaa"; ctx.font = "8px monospace"; ctx.fillText("VCC", c.x+18, c.y+18); ctx.fillText("GND", c.x+18, c.y+45); ctx.fillText("OUT", c.x+60, c.y+33);
            }
            else if (c.type === 'RADION') {
                ctx.strokeStyle = c.active ? "#00ff41" : "#111"; ctx.lineWidth = 2;
                ctx.fillStyle = "#111"; ctx.fillRect(c.x+35, c.y+20, 40, 40);
                ctx.strokeStyle = "#555"; ctx.strokeRect(c.x+35, c.y+20, 40, 40);
                ctx.fillStyle = "#fff"; ctx.font = "bold 10px monospace"; ctx.fillText("RADION", c.x+38, c.y+35);
                ctx.font = "9px monospace"; ctx.fillText("1.0", c.x+45, c.y+50);
                ctx.fillStyle = "#000"; ctx.font = "9px monospace";
                ctx.fillText("VCC", c.x+20, c.y+20); ctx.fillText("GND", c.x+20, c.y+50); ctx.fillText("GND", c.x+20, c.y+80);
                ctx.fillText("D1", c.x+80, c.y+35); ctx.fillText("D2", c.x+80, c.y+65);
                if (c.active && !c.burned) {
                    ctx.fillStyle = "#00ff41"; ctx.beginPath(); ctx.arc(c.x+90, c.y+10, 2, 0, Math.PI*2); ctx.fill();
                }
            }
            else if (c.type === 'BATTERY') {
                ctx.fillStyle = "#00ff41"; ctx.font = "12px monospace"; ctx.fillText(`BAT ${c.val}V`, c.x+25, c.y+35);
            } else if (c.type === 'CAPACITOR') {
                ctx.fillStyle = `rgb(0, ${Math.min(255, c.charge*2.55)}, 0)`; 
                ctx.fillRect(c.x+40, c.y+10, 20, 40); ctx.strokeStyle = "#fff"; ctx.strokeRect(c.x+40, c.y+10, 20, 40);
                ctx.fillStyle = "#fff"; ctx.font = "10px monospace"; ctx.fillText(`${Math.floor(c.charge)}%`, c.x+35, c.y+65);
                ctx.font = "9px monospace"; ctx.fillText(`${c.val}uF`, c.x+35, c.y+8);
                ctx.beginPath(); ctx.moveTo(c.x+35, c.y+15); ctx.lineTo(c.x+35, c.y+45); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+45, c.y+15); ctx.lineTo(c.x+45, c.y+45); ctx.stroke();
            } else if (c.type === 'TRANSISTOR') {
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(c.x+50, c.y+30, 20, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+40, c.y+15); ctx.lineTo(c.x+40, c.y+45); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+40, c.y+30); ctx.lineTo(c.x+20, c.y+50); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+40, c.y+20); ctx.lineTo(c.x+60, c.y+10); ctx.lineTo(c.x+60, c.y+10); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(c.x+40, c.y+40); ctx.lineTo(c.x+80, c.y+30); ctx.stroke();
                ctx.fillStyle = "#fff";
                if (c.mode === 'NPN') { ctx.beginPath(); ctx.moveTo(c.x+70, c.y+32); ctx.lineTo(c.x+60, c.y+35); ctx.lineTo(c.x+62, c.y+28); ctx.fill(); } 
                else { ctx.beginPath(); ctx.moveTo(c.x+45, c.y+39); ctx.lineTo(c.x+55, c.y+36); ctx.lineTo(c.x+53, c.y+43); ctx.fill(); }
                ctx.font = "10px monospace"; ctx.fillText(c.mode, c.x+35, c.y+33);
                ctx.fillStyle = "#aaa"; ctx.font="8px Arial"; ctx.fillText("C", c.x+25, c.y+15); ctx.fillText("E", c.x+70, c.y+25); ctx.fillText("B", c.x+25, c.y+45);
            } else if (c.type === 'RESISTOR') {
                ctx.strokeStyle = c.burned ? "#e74c3c" : "#888"; ctx.beginPath();
                ctx.moveTo(c.x+20, c.y+30); ctx.lineTo(c.x+30, c.y+20); ctx.lineTo(c.x+40, c.y+40);
                ctx.lineTo(c.x+50, c.y+20); ctx.lineTo(c.x+60, c.y+40); ctx.lineTo(c.x+70, c.y+30); ctx.stroke();
                ctx.fillStyle = "#00ff41"; ctx.font = "10px monospace"; ctx.fillText(`${c.val}Œ©`, c.x+35, c.y+15);
            } else if (['AND','OR','NOT','XOR'].includes(c.type)) {
                ctx.strokeStyle = c.active && !c.burned ? "#3498db" : (c.burned ? "#e74c3c" : "#555");
                if (c.type === 'AND') { ctx.beginPath(); ctx.moveTo(c.x+30, c.y+15); ctx.lineTo(c.x+60, c.y+15); ctx.arc(c.x+60, c.y+30, 15, -Math.PI/2, Math.PI/2); ctx.lineTo(c.x+30, c.y+45); ctx.closePath(); ctx.stroke(); }
                else if (c.type === 'OR') { ctx.beginPath(); ctx.moveTo(c.x+30, c.y+15); ctx.quadraticCurveTo(c.x+50, c.y+15, c.x+70, c.y+30); ctx.quadraticCurveTo(c.x+50, c.y+45, c.x+30, c.y+45); ctx.quadraticCurveTo(c.x+45, c.y+30, c.x+30, c.y+15); ctx.stroke(); }
                else if (c.type === 'XOR') { 
                    ctx.beginPath(); ctx.moveTo(c.x+35, c.y+15); ctx.quadraticCurveTo(c.x+55, c.y+15, c.x+70, c.y+30); ctx.quadraticCurveTo(c.x+55, c.y+45, c.x+35, c.y+45); ctx.quadraticCurveTo(c.x+50, c.y+30, c.x+35, c.y+15); ctx.stroke(); 
                    ctx.beginPath(); ctx.moveTo(c.x+28, c.y+15); ctx.quadraticCurveTo(c.x+43, c.y+30, c.x+28, c.y+45); ctx.stroke();
                }
                else if (c.type === 'NOT') { 
                    ctx.beginPath(); ctx.moveTo(c.x+30, c.y+15); ctx.lineTo(c.x+70, c.y+30); ctx.lineTo(c.x+30, c.y+45); ctx.closePath(); ctx.stroke(); 
                    ctx.beginPath(); ctx.arc(c.x+73, c.y+30, 3, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = "#aaa"; ctx.font = "8px Arial"; ctx.fillText("PWR", c.x+5, c.y+12); ctx.fillText("IN", c.x+5, c.y+55);
                }
                ctx.fillStyle = "#3498db"; ctx.font = "bold 12px monospace"; ctx.fillText(c.type, c.x+(c.type==='NOT'?40:35), c.y+33);
            }
            ctx.restore();

            c.nodes.forEach(n => {
                ctx.fillStyle = (n.id==='+'||n.id==='A'||n.id==='M1'||n.id==='R1'||n.id==='I1'||n.id==='I2'||n.id==='PWR'||n.id==='IN'||n.id==='C+'||n.id==='VCC') ? "#00ff41" : "#ff3131";
                if (c.type === 'TRANSISTOR' || c.type === 'MUX' || n.id==='S' || n.id==='COM' || n.id==='OUT') ctx.fillStyle = "#3498db"; 
                if (c.type === 'RADION' && (n.id === 'D1' || n.id === 'D2')) ctx.fillStyle = "#2ecc71";
                if (c.type === 'RADION' && (n.id === 'GND' || n.id === 'G')) ctx.fillStyle = "#ff3131";

                if (c.type === 'RELAY' && n.id === 'NO') ctx.fillStyle = "#ff3131";
                ctx.beginPath(); ctx.arc(c.x+n.x, c.y+n.y, 6, 0, Math.PI*2); ctx.fill();
                if(n.signal) { ctx.strokeStyle="#00ff41"; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(c.x+n.x, c.y+n.y, 8, 0, Math.PI*2); ctx.stroke(); }
            });
        });
        
        if (selectionBox) {
            ctx.strokeStyle = "#3498db"; ctx.lineWidth = 1; ctx.setLineDash([5, 5]);
            ctx.strokeRect(selectionBox.x, selectionBox.y, selectionBox.w, selectionBox.h);
            ctx.fillStyle = "rgba(52, 152, 219, 0.2)"; ctx.fillRect(selectionBox.x, selectionBox.y, selectionBox.w, selectionBox.h); ctx.setLineDash([]);
        }

        ctx.strokeStyle = "white"; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(vMouse.x, vMouse.y, 10, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(vMouse.x-15, vMouse.y); ctx.lineTo(vMouse.x+15, vMouse.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(vMouse.x, vMouse.y-15); ctx.lineTo(vMouse.x, vMouse.y+15); ctx.stroke();

        ctx.restore();
        const modeText = isDesktopMode ? "MODO PC" : "MODO MOVIL";
        ctx.fillStyle = "rgba(0, 255, 65, 0.3)"; ctx.font = "bold 12px monospace"; ctx.textAlign = "right";
        ctx.fillText(`Simulic Pro 1.6 [MANUAL]`, canvas.width - 15, canvas.height - 15); ctx.textAlign = "left"; 

        requestAnimationFrame(draw);
    }
    draw();
</script>
</body>
</html>
